## 标题：高级工程师任务执行规则
### 适用范围：所有任务
### 规则说明：
你是一位经验丰富的高级软件工程师，专注于编写高质量、生产可用的代码。擅长在不引入副作用的前提下，完成精准的函数级变更、模块集成与缺陷修复。
在执行任何任务时，必须严格遵守以下流程规范，不得跳过或简化任一步骤。：
- 1.先明确任务范围
在编写任何代码之前，必须先明确任务的处理方式。确认你对任务目标的理解无误。
撰写一份清晰的计划，说明将会涉及哪些函数、模块或组件，并解释原因。未完成以上步骤并合理推理之前，禁止开始编码。
- 2.找到精确的代码插入点
明确指出变更应落地到哪个文件的哪一行。严禁对无关文件进行大范围修改。
如需涉及多个文件，必须逐一说明每个文件的必要性。除非任务明确要求，否则不得新增抽象、重构已有结构。
- 3.仅做最小且封闭的更改
只编写为满足任务而必须实现的代码。
严禁任何“顺便”性质的修改或推测性变动。
所有逻辑必须做到隔离，确保不影响已有流程。
- 4.全面复查每一项变更
检查代码是否正确、符合任务范围，避免副作用。
保证代码风格与现有代码保持一致，防止引入回归问题。明确确认此改动是否会影响到下游流程。
- 5.清晰交付成果
做好代码变更的版本日志，做好新增及变化代码相应的注释，严禁随意修改删除已有注释。
总结变更内容及其原因。
列出所有被修改的文件及每个文件的具体改动。如果有任何假设或风险，请明确标注以供评审。
最终提交的代码应该是涉及到代码变更的整个代码文件，禁止提供有折叠的不完整代码块。
### 提醒：
你不是副驾驶、助手或头脑风暴的参与者。你是负责高杠杆、生产安全级变更的高级工程师。请勿即兴设计或偏离规范。

## 项目新架构
desktop_center/
.
├── .gitignore
├── app.py
├── config.ini
├── icon.ico
├── icon.png
├── README.md
├── requirements.txt
├── src/
│   ├── __init__.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── context.py
│   │   ├── plugin_interface.py
│   │   └── plugin_manager.py
│   ├── features/
│   │   ├── __init__.py
│   │   ├── alert_center/
│   │   │   ├── __init__.py
│   │   │   ├── database_extensions.py
│   │   │   ├── plugin.py
│   │   │   ├── README.md
│   │   │   ├── controllers/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── alerts_page_controller.py
│   │   │   │   ├── history_controller.py
│   │   │   │   ├── statistics_dialog_controller.py
│   │   │   │   └── statistics/
│   │   │   │       ├── __init__.py
│   │   │   │       ├── custom_analysis_controller.py
│   │   │   │       ├── hourly_stats_controller.py
│   │   │   │       ├── ip_activity_controller.py
│   │   │   │       ├── multidim_analysis_controller.py
│   │   │   │       └── type_stats_controller.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── custom_analysis_model.py
│   │   │   │   ├── history_model.py
│   │   │   │   └── statistics_model.py
│   │   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   └── alert_receiver.py
│   │   │   ├── views/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── alerts_page_view.py
│   │   │   │   ├── history_dialog_view.py
│   │   │   │   ├── statistics_dialog_view.py
│   │   │   │   └── statistics/
│   │   │   │       ├── __init__.py
│   │   │   │       ├── custom_analysis_view.py
│   │   │   │       ├── hourly_stats_view.py
│   │   │   │       ├── ip_activity_view.py
│   │   │   │       ├── multidim_analysis_view.py
│   │   │   │       └── type_stats_view.py
│   │   │   └── widgets/
│   │   │       ├── __init__.py
│   │   │       ├── date_filter_widget.py
│   │   │       └── ip_filter_widget.py
│   │   └── window_arranger/
│   │       ├── __init__.py
│   │       ├── plugin.py
│   │       ├── README.md
│   │       ├── controllers/
│   │       │   ├── __init__.py
│   │       │   ├── arranger_controller.py
│   │       │   └── sorting_strategy_manager.py
│   │       ├── models/
│   │       │   ├── __init__.py
│   │       │   └── window_info.py
│   │       ├── services/
│   │       │   ├── __init__.py
│   │       │   └── monitor_service.py
│   │       ├── sorting_strategies/
│   │       │   ├── __init__.py
│   │       │   ├── default_sort_strategy.py
│   │       │   ├── numeric_sort_strategy.py
│   │       │   └── sort_strategy_interface.py
│   │       └── views/
│   │           ├── __init__.py
│   │           ├── arranger_page_view.py
│   │           └── settings_dialog_view.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── config_service.py
│   │   ├── database_service.py
│   │   ├── notification_service.py
│   │   └── webhook_service.py
│   ├── ui/
│   │   ├── __init__.py
│   │   ├── action_manager.py
│   │   ├── main_window.py
│   │   └── settings_page.py
│   └── utils/
│       ├── __init__.py
│       ├── exception_handler.py
│       └── tray_manager.py
└── tests/
    └── test_config_service.py

        
- 终极解耦: “告警中心”和未来的“进程排序器”完全不知道对方的存在。它们只与平台核心的接口和上下文交互。
- 可扩展性极强:
    添加新功能: 只需在 src/features/ 目录下创建一个新文件夹，实现 IFeaturePlugin 接口，应用重启后就会自动加载，无需修改任何核心代码。
    扩展子功能: 在插件内部，你依然可以沿用MVC等模式来组织代码，保持子功能的清晰。
- 职责清晰:
src/core: 定义游戏规则。
src/features: 玩家。
app.py: 游戏裁判和场地。
src/services: 公共设施。
- 利于团队协作: 不同的开发者可以并行开发不同的插件，只要都遵守 IFeaturePlugin 接口，就不会互相干扰。
- 按需加载: 平台可以被配置为只加载某些插件，实现不同版本（基础版/专业版）的软件分发。



## app.py

```python
# desktop_center/app.py
import sys
import os
import logging
import configparser
from PySide6.QtWidgets import QApplication, QMessageBox
from PySide6.QtGui import QIcon 
import ctypes # 【新增】导入 ctypes 用于Windows AppUserModelID
import logging.handlers

# --- 1. 导入项目核心模块 ---
# 遵循先导入服务、再导入UI、最后导入管理器的逻辑顺序
from src.services.config_service import ConfigService
from src.services.database_service import DatabaseService
from src.services.notification_service import NotificationService
from src.services.webhook_service import WebhookService 
from src.ui.main_window import MainWindow
from src.ui.settings_page import SettingsPageWidget
from src.ui.action_manager import ActionManager
from src.utils.tray_manager import TrayManager
from src.utils.exception_handler import setup_exception_handler
from src.core.context import ApplicationContext
from src.core.plugin_manager import PluginManager


# --- 2. 全局应用程序常量 ---
# 将所有硬编码的字符串和配置集中在此处，便于管理
APP_VERSION = "5.3.8-Code-Refinement"
APP_NAME_DEFAULT = "Desktop Control & Monitoring Center"
CONFIG_FILE = 'config.ini'
DB_FILE = 'history.db'
LOG_FILE = 'app.log'
PNG_ICON_FILE = 'icon.png'  # 用于窗口、托盘等
ICO_ICON_FILE = 'icon.ico'  # 专门用于Windows原生通知

# 【新增】定义一个唯一的应用程序用户模型ID
APP_USER_MODEL_ID = "com.YourCompany.DesktopCenter.v1"


def setup_logging():
    """
    配置全局日志记录器。
    此函数设计为在应用生命周期中最早被调用，它会预读配置文件以获取日志级别。
    """
    # 默认日志级别，以防配置文件无法读取
    log_level_str = "INFO"
    
    # 步骤1: 预加载配置以获取日志级别，不实例化完整的ConfigService
    try:
        pre_parser = configparser.ConfigParser()
        if pre_parser.read(CONFIG_FILE, encoding='utf-8-sig'):
            log_level_str = pre_parser.get('Logging', 'level', fallback='INFO').upper()
    except (configparser.Error, IOError):
        # 即使日志系统尚未完全建立，也可以使用Python的内置警告
        import warnings
        warnings.warn(f"无法预读配置文件 '{CONFIG_FILE}' 以获取日志级别，将使用默认的 'INFO' 级别。")

    # 步骤2: 将字符串级别转换为logging模块的常量
    log_level = getattr(logging, log_level_str, logging.INFO)

    # 步骤3: 配置日志系统
    file_handler = logging.handlers.RotatingFileHandler(
        LOG_FILE, 
        maxBytes=2 * 1024 * 1024,
        backupCount=5,
        encoding='utf-8',
        mode='a'
    )
    stream_handler = logging.StreamHandler(sys.stdout)

    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(levelname)s - [%(threadName)s] - %(message)s',
        handlers=[
            file_handler,    # 使用配置好的轮转文件处理器
            stream_handler
        ]
    )
    # 打印启动横幅
    logging.info("=" * 80)
    logging.info(f"--- 应用程序启动流程开始 (v{APP_VERSION}) ---")
    logging.info("=" * 80)
    logging.info(f"[STEP 0] 日志系统初始化完成。日志级别设置为: {log_level_str}")


class ApplicationOrchestrator:
    """
    【平台核心】应用协调器。
    
    这是整个应用程序的“大脑”，负责以正确的顺序组装所有核心组件、
    服务和UI，加载插件，并管理应用的生命周期（启动、运行、关闭）。
    """
    def __init__(self):
        """初始化整个应用程序的架构。"""
        logging.info("[STEP 1.0] ApplicationOrchestrator: 开始初始化平台核心...")

        # --- 1.1 基础环境准备 ---
        # 计算所有资源文件的绝对路径，以避免在不同工作目录下出现问题
        project_root = os.path.dirname(os.path.abspath(__file__))
        self.config_path = os.path.join(project_root, CONFIG_FILE)
        self.db_path = os.path.join(project_root, DB_FILE)
        self.png_icon_path = os.path.join(project_root, PNG_ICON_FILE)
        self.ico_icon_path = os.path.join(project_root, ICO_ICON_FILE)
        logging.info("  - 基础路径计算完成。")

        # --- 1.2 初始化Qt应用实例 ---
        self.app = QApplication(sys.argv)
        
        # 【变更】为Windows设置AppUserModelID，以确保任务栏图标的正确关联
        if sys.platform == "win32":
            try:
                # 设置AppUserModelID必须在QApplication实例创建后、主窗口显示前
                ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(APP_USER_MODEL_ID)
                logging.info(f"  - Windows AppUserModelID '{APP_USER_MODEL_ID}' 已设置。")
            except Exception as e:
                logging.warning(f"  - 无法设置Windows AppUserModelID: {e}")

        # 设置QApplication的全局图标，这将影响任务栏图标
        self.app.setWindowIcon(QIcon(self.png_icon_path)) 
        self.app.setQuitOnLastWindowClosed(False) # 确保关闭主窗口时应用不退出
        logging.info("  - Qt Application实例初始化完成。")

        # --- 1.3 初始化核心后台服务 ---
        # 这些服务不依赖UI，是应用的基础数据和配置提供者
        self.config_service = ConfigService(self.config_path)
        try:
            self.db_service = DatabaseService(self.db_path)
            self.db_service.init_db()
        except Exception as e:
            logging.critical(f"数据库服务初始化失败，程序无法启动: {e}", exc_info=True)
            sys.exit(1)
        
        # 通知服务依赖于配置服务，因此在其后初始化
        app_name = self.config_service.get_value("General", "app_name", APP_NAME_DEFAULT)
        self.notification_service = NotificationService(
            app_name=app_name,
            app_icon=self.ico_icon_path,
            config_service=self.config_service
        )
        # 【新增】实例化 WebhookService 具体配置参数应该在插件平台设置
        self.webhook_service = WebhookService()
        logging.info("  - 核心后台服务 (Config, Database, Notification, Webhook) 初始化完成。") # 【修改】更新日志

        # --- 1.4 初始化核心UI组件 ---
        # 这些是平台级的UI元素，所有插件都可能与之交互
        self.window = MainWindow()
        self.window.setWindowTitle(app_name)
        self.tray_manager = TrayManager(self.app, self.window, self.png_icon_path)
        self.action_manager = ActionManager(self.app)
        logging.info("  - 核心UI组件 (MainWindow, TrayManager, ActionManager) 初始化完成。")

        # --- 1.5 创建共享上下文 (ApplicationContext) ---
        # 这是整个架构的核心，它像一个“工具箱”，被传递给所有插件，
        # 使插件能够安全地访问所有共享的平台资源。
        self.context = ApplicationContext(
            app=self.app,
            main_window=self.window,
            config_service=self.config_service,
            db_service=self.db_service,
            tray_manager=self.tray_manager,
            action_manager=self.action_manager,
            notification_service=self.notification_service,
            webhook_service=self.webhook_service
        )
        logging.info("  - 共享的 ApplicationContext 创建完成。")

        # --- 1.6 初始化插件系统 ---
        self.plugin_manager = PluginManager(self.context)
        logging.info("[STEP 2.0] 开始加载和初始化所有插件...")
        self.plugin_manager.load_plugins()
        self.plugin_manager.initialize_plugins()
        logging.info("[STEP 2.3] 所有插件加载和初始化完毕。")
        
        # --- 1.7 添加平台级页面 ---
        # 某些页面（如“设置”）是平台的一部分，不属于任何插件
        logging.info("[STEP 3.0] 添加平台级页面...")
        self._add_core_pages()

        # --- 1.8 连接全局信号与槽 ---
        # 这是最后一步，将所有组件连接起来，形成完整的应用逻辑
        logging.info("[STEP 4.0] 连接应用程序全局信号...")
        # 【变更】将信号连接放在启动后台服务之前，避免竞态条件
        self.tray_manager.quit_requested.connect(self.app.quit)
        self.app.aboutToQuit.connect(self.shutdown)
        logging.info("  - 信号连接完成。")
        
        logging.info("[STEP 4.1] 平台核心初始化流程结束。")

    def _add_core_pages(self):
        """将不属于任何插件的核心页面（如设置页面）添加到主窗口。"""
        self.settings_page = SettingsPageWidget(self.config_service)
        self.window.add_page("设置", self.settings_page)
        logging.info("  - 核心页面 '设置' 已添加。")

    def run(self):
        """启动应用程序的事件循环，并处理启动时的UI逻辑。"""
        logging.info("[STEP 5.0] 启动Qt事件循环...")
        try:
            # 启动托盘图标的后台监听
            # 【变更】信号已在init阶段连接，此处只负责启动
            self.tray_manager.run()
            
            # 发送启动通知（如果配置允许）
            if self.config_service.get_value("General", "show_startup_notification", "true").lower() == 'true':
                self.context.notification_service.show(
                    title=f"{self.window.windowTitle()} 已启动",
                    message="程序正在后台运行。您可以通过系统托盘图标访问主窗口或退出程序。"
                )

            # 根据配置决定是显示主窗口还是最小化启动
            if self.config_service.get_value("General", "start_minimized", "false").lower() != 'true':
                self.window.center_on_screen()
                self.window.show()
                
            # 阻塞并开始执行Qt事件循环
            sys.exit(self.app.exec())
        except Exception as e:
            logging.critical(f"应用程序顶层发生未捕获的异常: {e}", exc_info=True)
            sys.exit(1)

    def shutdown(self):
        """
        【变更】执行集中的、安全的关闭流程，确保所有资源被正确释放。
        """
        logging.info("[STEP 6.0] 应用程序关闭流程开始...")
        
        logging.info("  - [6.1] 停止系统托盘图标...")
        # 【新增】将托盘图标的关闭操作集中到此处
        self.tray_manager.stop_icon()
        
        logging.info("  - [6.2] 关闭所有插件...")
        self.plugin_manager.shutdown_plugins()
        
        # 【新增】安全地关闭 WebhookService 线程池
        logging.info("  - [6.3] 清理 Webhook 服务线程池...")
        self.webhook_service.thread_pool.clear()
        self.webhook_service.thread_pool.waitForDone()

        logging.info("  - [6.4] 关闭数据库服务...")
        self.db_service.close()
        
        logging.info("[STEP 6.5] 应用程序关闭流程结束。")


if __name__ == '__main__':
    """应用程序的主入口点。"""
    try:
        # 确保所有相对路径都是基于此文件所在目录的
        os.chdir(os.path.dirname(os.path.abspath(__file__)))
        
        # 1. 优先设置日志记录，以便记录所有后续步骤
        setup_logging()
        
        # 2. 其次设置全局异常处理，作为最后一道安全防线
        setup_exception_handler()
        
        # 3. 实例化并运行应用协调器
        main_app = ApplicationOrchestrator()
        main_app.run()
        
    except Exception as e:
        # 这个except块用于捕获在ApplicationOrchestrator初始化期间发生的、
        # 无法被全局异常钩子捕获的致命错误。
        logging.critical(f"应用程序在初始化阶段发生致命错误，无法启动: {e}", exc_info=True)
        QMessageBox.critical(None, "启动失败", f"应用程序无法启动，请查看日志文件 app.log 获取详情。\n\n错误: {e}")
        sys.exit(1)
```

## context.py

```python
# desktop_center/src/core/context.py
from dataclasses import dataclass
from typing import TYPE_CHECKING
from PySide6.QtWidgets import QApplication

# 【修改】使用类型检查块来避免循环导入
if TYPE_CHECKING:
    from src.services.config_service import ConfigService
    from src.services.database_service import DatabaseService
    from src.services.notification_service import NotificationService
    from src.services.webhook_service import WebhookService
    from src.utils.tray_manager import TrayManager
    from src.ui.action_manager import ActionManager

@dataclass
class ApplicationContext:
    """一个数据类，持有所有核心/共享服务和组件的引用，供插件使用。"""
    app: QApplication
    main_window: 'MainWindow'
    config_service: 'ConfigService'
    db_service: 'DatabaseService'
    tray_manager: 'TrayManager'
    action_manager: 'ActionManager'
    notification_service: 'NotificationService'
    webhook_service: 'WebhookService'
```
## plugin_interface.py

```python
# desktop_center/src/core/plugin_interface.py
from abc import ABC, abstractmethod
from PySide6.QtWidgets import QWidget
from .context import ApplicationContext

class IFeaturePlugin(ABC):
    """
    【文档化】所有功能插件必须实现的接口（契约）。

    这个接口定义了一个插件的基本行为和与平台核心交互的方式。
    平台核心通过这些方法来识别、加载、初始化和关闭插件。
    """
    
    @abstractmethod
    def name(self) -> str:
        """
        返回插件的唯一内部名称。

        这个名称用于日志记录、内部管理和插件间的唯一识别。
        它应该是简短、无空格的ASCII字符串，例如 "alert_center"。

        Returns:
            str: 插件的唯一标识符。
        """
        pass

    @abstractmethod
    def display_name(self) -> str:
        """
        返回插件在用户界面上显示的名称。

        这个名称将用于主窗口的导航栏、菜单项等面向用户的地方。
        它可以是任何UTF-8字符串，例如 "告警中心"。

        Returns:
            str: 插件的显示名称。
        """
        pass
        
    @abstractmethod
    def load_priority(self) -> int:
        """
        返回插件的加载优先级，数字越小，优先级越高。

        这个值决定了插件 `initialize` 方法的调用顺序。
        如果插件A依赖于插件B，则插件B的优先级应高于（即数值小于）插件A。

        建议使用以下范围：
        - 0-99: 核心服务型插件
        - 100-199: 普通独立功能插件
        - 200+: 依赖其他插件的功能插件

        Returns:
            int: 加载优先级。
        """
        pass

    def initialize(self, context: ApplicationContext):
        """
        初始化插件。

        平台核心在加载所有插件后会调用此方法。插件应该在这里：
        1. 保存 `context` 的引用，以便后续访问共享服务。
        2. 创建并准备其UI页面（如果需要）。
        3. 创建并准备其后台服务（如果需要）。
        4. 注册全局动作到 `ActionManager`。
        5. 连接到核心或其他服务的信号。

        Args:
            context (ApplicationContext): 包含所有共享服务和组件的应用上下文。
        """
        self.context = context
        self.background_services = []
        self.page_widget = None

    def get_page_widget(self) -> QWidget | None:
        """
        返回此插件的主UI页面控件实例。

        如果插件没有UI页面，应返回 `None`。
        返回的控件将被添加到主窗口的内容区域。

        Returns:
            QWidget | None: 插件的UI页面实例或None。
        """
        return self.page_widget

    def get_background_services(self) -> list:
        """
        返回此插件需要在后台运行的服务列表。

        这些服务通常是继承自 `QThread` 的对象。
        平台核心会自动调用每个服务的 `start()` 方法。

        Returns:
            list: 需要在后台运行的服务实例列表。
        """
        return self.background_services

    def shutdown(self):
        """
        在应用程序关闭时，安全地关闭插件。

        平台核心在退出前会调用此方法。插件应该在这里：
        1. 停止并等待所有后台线程结束。
        2. 断开所有信号连接。
        3. 释放所有持有的资源。

        默认实现会尝试优雅地停止 `get_background_services()` 返回的服务。
        如果插件有更复杂的关闭逻辑，应重写此方法。
        """
        for service in self.background_services:
            if hasattr(service, 'running') and hasattr(service, 'quit'):
                if service.running:
                    service.running = False
                    service.quit()
                    service.wait(5000)
```

## plugin_manager.py

```python
# desktop_center/src/core/plugin_manager.py
import importlib
import pkgutil
import logging
from PySide6.QtWidgets import QWidget
from PySide6.QtCore import QThread
from src.core.plugin_interface import IFeaturePlugin

class PluginManager:
    """负责发现、加载和管理所有插件的管理器。"""
    def __init__(self, context):
        self.context = context
        self.plugins: list[IFeaturePlugin] = []

    def load_plugins(self):
        """
        使用 walk_packages 递归地发现并加载所有在 src.features 包下的插件。
        """
        import src.features
        logging.info("[STEP 2.1] PluginManager: 开始扫描 'src/features' 目录以发现插件...")
        
        for module_info in pkgutil.walk_packages(path=src.features.__path__, prefix=src.features.__name__ + '.'):
            try:
                module = importlib.import_module(module_info.name)
                for item_name in dir(module):
                    item = getattr(module, item_name)
                    if isinstance(item, type) and issubclass(item, IFeaturePlugin) and item is not IFeaturePlugin:
                        if not any(isinstance(p, item) for p in self.plugins):
                            plugin_instance = item()
                            self.plugins.append(plugin_instance)
                            logging.info(f"  - 插件已发现并加载: {plugin_instance.name()} (from {module_info.name})")
            except Exception as e:
                logging.error(f"加载插件模块 {module_info.name} 时失败: {e}", exc_info=True)
        logging.info("[STEP 2.1] PluginManager: 插件扫描和加载完成。")


    def initialize_plugins(self):
        """初始化所有已加载的插件。"""
        logging.info("[STEP 2.2] PluginManager: 开始初始化所有已加载的插件...")
        self.plugins.sort(key=lambda p: p.load_priority())
        logging.info(f"  - 插件将按以下优先级顺序初始化: {[p.name() for p in self.plugins]}")
        
        for plugin in self.plugins:
            try:
                logging.info(f"  - 正在初始化插件: '{plugin.name()}' (优先级: {plugin.load_priority()})...")
                plugin.initialize(self.context)
                
                # 【修改】对插件返回值进行健壮性检查
                page_widget = plugin.get_page_widget()
                if page_widget:
                    if isinstance(page_widget, QWidget):
                        self.context.main_window.add_page(plugin.display_name(), page_widget)
                        logging.info(f"    - 插件 '{plugin.name()}' 的主页面已添加到主窗口。")
                    else:
                        logging.warning(f"    - 插件 '{plugin.name()}' 的 get_page_widget() 返回的不是有效QWidget，已忽略。")

                background_services = plugin.get_background_services()
                if background_services:
                    for service in background_services:
                        if isinstance(service, QThread) and hasattr(service, 'start'):
                            service.start()
                            logging.info(f"    - 已启动插件 '{plugin.name()}' 的后台服务: {type(service).__name__}")
                        else:
                            logging.warning(f"    - 插件 '{plugin.name()}' 返回的后台服务 {type(service).__name__} 不是有效的QThread，已忽略。")
                
                logging.info(f"  - 插件 '{plugin.name()}' 初始化完成。")
            except Exception as e:
                logging.error(f"初始化插件 {plugin.name()} 失败: {e}", exc_info=True)

    def shutdown_plugins(self):
        """安全关闭所有插件。"""
        for plugin in self.plugins:
            try:
                plugin.shutdown()
                logging.info(f"  - 插件 '{plugin.name()}' 已成功关闭。")
            except Exception as e:
                logging.error(f"关闭插件 {plugin.name()} 时发生错误: {e}", exc_info=True)
```

## config_service.py

```python
# desktop_center/src/services/config_service.py
import configparser
import logging
from typing import List, Tuple

class ConfigService:
    """
    健壮的配置服务，负责所有 config.ini 文件的读写逻辑。
    设计目标是即使在配置文件损坏或丢失的情况下也能让主程序安全启动。
    """
    def __init__(self, filepath: str):
        """
        初始化配置服务。

        Args:
            filepath (str): config.ini 文件的路径。
        """
        self.filepath = filepath
        self.config = configparser.ConfigParser()
        self.load_config()

    def load_config(self) -> None:
        """
        从磁盘加载配置文件。
        如果文件不存在或无法解析，将记录一个错误并使用一个空的配置对象，
        这可以防止应用程序在启动时崩溃。
        """
        try:
            # 使用utf-8-sig可以处理带有BOM头的UTF-8文件
            read_files = self.config.read(self.filepath, encoding='utf-8-sig')
            if not read_files:
                logging.warning(f"配置文件 '{self.filepath}' 未找到。将使用空配置。")
            else:
                logging.info(f"成功加载配置文件: {self.filepath}")
        except configparser.Error as e:
            logging.error(f"解析配置文件 '{self.filepath}' 失败: {e}")
            # 解析失败时重置为一个空对象，保证程序健壮性
            self.config = configparser.ConfigParser()

    def get_sections(self) -> List[str]:
        """获取所有配置区段的名称列表。"""
        return self.config.sections()

    def get_options(self, section: str) -> List[Tuple[str, str]]:
        """获取指定区段下的所有键值对。"""
        if self.config.has_section(section):
            return self.config.items(section)
        return []

    def get_value(self, section: str, option: str, fallback: str = None) -> str:
        """安全地获取一个配置值，可提供默认值。"""
        return self.config.get(section, option, fallback=fallback)

    def set_option(self, section: str, option: str, value: str) -> None:
        """设置一个配置值。如果区段不存在，则自动创建。"""
        if not self.config.has_section(section):
            self.config.add_section(section)
        self.config.set(section, option, str(value))

    def save_config(self) -> bool:
        """
        将当前配置状态写回文件。

        Returns:
            bool: 如果保存成功则返回 True，否则返回 False。
        """
        try:
            with open(self.filepath, 'w', encoding='utf-8') as configfile:
                self.config.write(configfile)
            logging.info(f"配置文件已成功保存到: {self.filepath}")
            return True
        except IOError as e:
            logging.error(f"保存配置文件到 '{self.filepath}' 失败: {e}")
            return False

```






## notification_service.py

```python
# desktop_center/src/services/notification_service.py
import logging
import os
from plyer import notification
from src.services.config_service import ConfigService

class NotificationService:
    """
    负责管理和显示桌面弹窗通知的核心服务。
    此版本使用系统的原生通知功能，通过 'plyer' 库实现。
    """
    def __init__(self, app_name: str, app_icon: str, config_service: ConfigService):
        """
        初始化通知服务。

        Args:
            app_name (str): 应用程序的名称，将显示在通知中。
            app_icon (str): 指向应用程序图标文件的路径 (.ico for Windows)。
            config_service (ConfigService): 配置服务实例。
        """
        self.app_name = app_name
        self.app_icon = app_icon
        self.config_service = config_service
        logging.info("通知服务 (NotificationService) 初始化完成。")

    def show(self, title: str, message: str, level: str = 'INFO'):
        """
        供所有插件调用的公共接口，用于显示一个系统原生通知。

        Args:
            title (str): 通知的标题。
            message (str): 通知的主体内容。
            level (str, optional): 通知的级别（暂未使用，为未来扩展保留）。
        """
        # 1. 检查全局配置是否允许弹窗
        if self.config_service.get_value("InfoService", "enable_desktop_popup", "true").lower() != 'true':
            logging.info("桌面通知被全局禁用，本次通知已忽略。")
            return

        # 2. 检查通知级别是否满足阈值 (未来可扩展)
        # ...

        # 3. 调用plyer发送通知
        try:
            # 确保图标文件存在
            icon_path = self.app_icon if os.path.exists(self.app_icon) else ''
            
            timeout_str = self.config_service.get_value("InfoService", "popup_timeout", "10")
            timeout = int(timeout_str) if timeout_str.isdigit() else 10
            
            notification.notify(
                title=title,
                message=message,
                app_name=self.app_name,
                app_icon=icon_path,
                timeout=timeout
            )
            logging.info(f"已发送系统通知: title='{title}'")
        except Exception as e:
            # plyer在某些环境下（如无GUI的服务器或缺少依赖）可能会失败
            logging.error(f"发送系统通知时发生错误: {e}", exc_info=True)
```

## webhook_service.py

```python
# desktop_center/src/services/webhook_service.py
import logging
import requests
from PySide6.QtCore import QObject, QRunnable, QThreadPool

class WebhookWorker(QRunnable):
    """
    一个在独立线程中发送 Webhook 请求的工作器，以避免阻塞调用方。
    """
    def __init__(self, url: str, payload: dict):
        super().__init__()
        self.url = url
        self.payload = payload

    def run(self):
        """执行 HTTP POST 请求。"""
        try:
            response = requests.post(self.url, json=self.payload, timeout=5)
            response.raise_for_status() # 如果状态码不是 2xx，则抛出异常
            logging.info(f"Webhook 已成功推送到 {self.url}，响应: {response.status_code}")
        except requests.exceptions.RequestException as e:
            logging.error(f"推送 Webhook 到 {self.url} 失败: {e}")

class WebhookService(QObject):
    """
    平台级共享服务，用于异步发送 Webhook (HTTP POST) 请求。
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.thread_pool = QThreadPool()
        # 设置线程池的最大线程数，以防滥用
        self.thread_pool.setMaxThreadCount(5) 
        logging.info("Webhook 服务 (WebhookService) 初始化完成。")

    def push(self, url: str, payload: dict):
        """
        异步地将一个 JSON payload 推送到指定的 URL。
        
        Args:
            url (str): 目标 URL。
            payload (dict): 要作为 JSON 发送的数据。
        """
        if not url or not url.startswith(('http://', 'https://')):
            logging.warning(f"无效的 Webhook URL: '{url}'，推送已取消。")
            return
            
        worker = WebhookWorker(url, payload)
        self.thread_pool.start(worker)
```

## main_window.py

```python
# desktop_center/src/ui/main_window.py
import logging
# 【新增】导入 QApplication 以便访问屏幕信息
from PySide6.QtWidgets import (QApplication, QMainWindow, QWidget, QListWidget, 
                               QListWidgetItem, QHBoxLayout, QStackedWidget)
from PySide6.QtCore import QEvent, QSize

class MainWindow(QMainWindow):
    """
    主应用程序窗口框架。
    采用“导航-内容”布局，设计为可扩展的容器。
    它自身不实现任何具体功能页面，只提供添加和切换页面的能力。
    """
    def __init__(self, parent: QWidget = None):
        """
        初始化主窗口。

        Args:
            parent (QWidget, optional): 父组件。默认为 None。
        """
        super().__init__(parent)
        self.setWindowTitle("Application Skeleton") # 初始标题，可由app.py覆盖
        self.setGeometry(100, 100, 900, 700) # 初始尺寸

        # --- 创建主布局 ---
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        main_layout = QHBoxLayout(main_widget)
        main_layout.setContentsMargins(0, 0, 0, 0) # 无边距，让子组件填满
        main_layout.setSpacing(0)

        # --- 左侧导航栏 ---
        self.nav_list = QListWidget()
        self.nav_list.setFixedWidth(180)
        self.nav_list.setStyleSheet("""
            QListWidget {
                background-color: #f0f0f0;
                border: none;
                font-size: 14px;
                padding-top: 10px;
            }
            QListWidget::item {
                padding: 12px 20px;
                border-bottom: 1px solid #e0e0e0;
            }
            QListWidget::item:selected {
                background-color: #0078d4;
                color: white;
                font-weight: bold;
                border-left: 5px solid #005a9e;
            }
        """)
        main_layout.addWidget(self.nav_list)
        
        # --- 右侧内容区 (使用QStackedWidget实现页面切换) ---
        self.stacked_widget = QStackedWidget()
        main_layout.addWidget(self.stacked_widget)

        # --- 连接信号与槽 ---
        # 当导航栏的当前项改变时，切换到对应的页面
        self.nav_list.currentRowChanged.connect(self.stacked_widget.setCurrentIndex)
    
    def add_page(self, title: str, widget: QWidget) -> None:
        """
        向主窗口动态添加一个功能页面。

        Args:
            title (str): 显示在导航栏中的页面标题。
            widget (QWidget): 要添加的功能页面的实例。
        """
        # 将页面实例添加到堆栈窗口中
        self.stacked_widget.addWidget(widget)
        # 将页面标题添加到导航列表
        self.nav_list.addItem(QListWidgetItem(title))
        
        # 默认选中第一个添加的页面
        if self.nav_list.count() == 1:
            self.nav_list.setCurrentRow(0)

    def closeEvent(self, event: QEvent) -> None:
        """
        重写窗口关闭事件。
        默认行为是隐藏窗口而不是退出应用，以便在系统托盘中继续运行。
        
        Args:
            event (QEvent): 关闭事件对象。
        """
        logging.info("关闭事件触发：隐藏主窗口到系统托盘。")
        event.ignore()  # 忽略默认的关闭行为（即退出）
        self.hide()     # 将窗口隐藏

    def center_on_screen(self) -> None:
        """
        【新增】将窗口移动到主屏幕的中央。
        """
        try:
            # 获取主屏幕的几何信息
            screen_geometry = QApplication.primaryScreen().geometry()
            # 获取窗口自身的几何信息 (包括标题栏)
            window_geometry = self.frameGeometry()
            # 计算居中位置
            center_point = screen_geometry.center()
            window_geometry.moveCenter(center_point)
            # 移动窗口到计算出的位置
            self.move(window_geometry.topLeft())
            logging.info(f"主窗口已居中到屏幕位置: {window_geometry.topLeft().toTuple()}")
        except Exception as e:
            logging.warning(f"无法自动居中窗口: {e}", exc_info=True)
```

## action_manager.py

```python
# desktop_center/src/ui/action_manager.py
from PySide6.QtCore import QObject
from PySide6.QtGui import QAction
from typing import Dict

class ActionManager(QObject):
    """
    【修改】中央动作管理器，作为一个通用的动作注册中心。
    插件或其他组件可以注册全局可用的QAction，实现功能触发和UI组件的解耦。
    它本身不应持有任何特定功能的动作实例。
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self._actions: Dict[str, QAction] = {}

    def register_action(self, name: str, action: QAction) -> None:
        """
        【新增】注册一个全局动作。

        Args:
            name (str): 动作的唯一标识符，例如 'alert_center.show_history'。
            action (QAction): 要注册的QAction实例。
        
        Raises:
            ValueError: 如果同名动作已被注册。
        """
        if name in self._actions:
            raise ValueError(f"动作 '{name}' 已经被注册。")
        self._actions[name] = action

    def get_action(self, name: str) -> QAction | None:
        """
        【新增】根据名称获取一个已注册的动作。

        Args:
            name (str): 动作的唯一标识符。

        Returns:
            QAction | None: 返回找到的QAction实例，如果未找到则返回None。
        """
        return self._actions.get(name)
```

## settings_page.py

```python
# desktop_center/src/ui/settings_page.py
import logging
from PySide6.QtWidgets import (QWidget, QLabel, QVBoxLayout, QGroupBox,
                               QLineEdit, QPushButton, QMessageBox, QFormLayout,
                               QComboBox, QSpinBox, QScrollArea, QHBoxLayout)
from PySide6.QtCore import Qt, QEvent

from src.services.config_service import ConfigService

# 【修改】元数据结构添加 "default" 字段
SETTING_METADATA = {
    "General": {
        "app_name": {"widget": "lineedit", "label": "应用程序名称", "default": "Desktop Control & Monitoring Center"},
        "start_minimized": {"widget": "combobox", "label": "启动时最小化", "items": ["禁用", "启用"], "map": {"启用": "true", "禁用": "false"}, "default": "false"},
        "show_startup_notification": {"widget": "combobox", "label": "显示启动通知", "items": ["禁用", "启用"], "map": {"启用": "true", "禁用": "false"}, "default": "true"}
    },
    # 【新增】日志设置的元数据，上面的notification也是本次新添加的
    "Logging": {
        "level": {"widget": "combobox", "label": "日志级别", "items": ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"], "default": "INFO"}
    },
    # 【新增】Webhook 默认设置的元数据
    "WebhookDefaults": {
        "default_host": {"widget": "lineedit", "label": "默认推送主机", "default": "127.0.0.1"},
        "default_port": {"widget": "spinbox", "label": "默认推送端口", "min": 1, "max": 65535, "default": 5000}
    },
    "InfoService": {
        "host": {"widget": "lineedit", "label": "监听地址", "col": 0, "default": "0.0.0.0"},
        "port": {"widget": "spinbox", "label": "监听端口", "min": 1024, "max": 65535, "col": 0, "default": 9527},
        "enable_desktop_popup": {"widget": "combobox", "label": "桌面弹窗通知", "items": ["禁用", "启用"], "map": {"启用": "true", "禁用": "false"}, "col": 0, "default": "true"},
        "popup_timeout": {"widget": "spinbox", "label": "弹窗显示时长 (秒)", "min": 1, "max": 300, "col": 1, "default": 10},
        "notification_level": {"widget": "combobox", "label": "通知级别阈值", "items": ["INFO", "WARNING", "CRITICAL"], "col": 1, "default": "INFO"},
        "load_history_on_startup": {"widget": "combobox", "label": "启动时加载历史", "items": ["不加载", "加载最近50条", "加载最近100条", "加载最近500条"], "map": {"不加载": "0", "加载最近50条": "50", "加载最近100条": "100", "加载最近500条": "500"}, "col": 1, "default": "100"}
    }
}

class SettingsPageWidget(QWidget):
    """
    “设置”功能页面。
    采用“元数据驱动”和“卡片式布局”进行重构，提升了可维护性和用户体验。
    """
    def __init__(self, config_service: ConfigService, parent=None):
        super().__init__(parent)
        self.config_service = config_service
        self.editors = {}

        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(15)

        title_label = QLabel("应用程序设置")
        title_label.setStyleSheet("font-size: 22px; font-weight: bold; margin-bottom: 10px; color: #333;")
        main_layout.addWidget(title_label)
        
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setStyleSheet("QScrollArea { border: none; background-color: transparent; }")
        
        content_widget = QWidget()
        self.settings_layout = QVBoxLayout(content_widget)
        self.settings_layout.setSpacing(15)
        self.settings_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        scroll_area.setWidget(content_widget)
        main_layout.addWidget(scroll_area)

        self._create_setting_cards()

        self.save_button = QPushButton("保存所有设置")
        self.save_button.setMinimumHeight(35)
        self.save_button.setStyleSheet("""
            QPushButton { font-size: 14px; font-weight: bold; background-color: #0078d4; color: white; border: none; border-radius: 5px; padding: 0 20px; }
            QPushButton:hover { background-color: #005a9e; }
            QPushButton:pressed { background-color: #004578; }
        """)
        self.save_button.clicked.connect(self.save_settings)
        main_layout.addWidget(self.save_button, 0, Qt.AlignmentFlag.AlignRight)

        self.installEventFilter(self)

    def _create_setting_cards(self):
        """根据元数据动态创建所有设置卡片。"""
        # 【修改】确保新卡片按预定顺序创建
        ordered_sections = ["General", "Logging", "WebhookDefaults", "InfoService"]
        for section in ordered_sections:
            if section in SETTING_METADATA:
                options_meta = SETTING_METADATA[section]
                card = QGroupBox(section)
                card.setStyleSheet("""
                    QGroupBox { font-size: 16px; font-weight: bold; color: #333; background-color: #fcfcfc; border: 1px solid #e0e0e0; border-radius: 8px; margin-top: 10px; }
                    QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; padding: 0 10px; left: 10px; background-color: #fcfcfc; }
                """)
                
                if section == "InfoService":
                    self._populate_multi_column_layout(card, section, options_meta)
                else:
                    form_layout = QFormLayout(card)
                    form_layout.setSpacing(12)
                    form_layout.setContentsMargins(20, 30, 20, 20)
                    self._populate_form_layout(form_layout, section, options_meta)
                
                self.settings_layout.addWidget(card)

    def _populate_multi_column_layout(self, parent_group: QGroupBox, section_name: str, options_meta: dict):
        """为InfoService卡片创建多列布局。"""
        main_hbox = QHBoxLayout(parent_group)
        main_hbox.setSpacing(40)
        main_hbox.setContentsMargins(20, 30, 20, 20)

        column1_layout = QFormLayout()
        column1_layout.setSpacing(12)
        column2_layout = QFormLayout()
        column2_layout.setSpacing(12)

        for key, meta in options_meta.items():
            target_layout = column1_layout if meta.get("col", 0) == 0 else column2_layout
            self._add_widget_to_form(target_layout, section_name, key, meta)
        
        main_hbox.addLayout(column1_layout)
        main_hbox.addLayout(column2_layout)

    def _populate_form_layout(self, form_layout: QFormLayout, section_name: str, options_meta: dict):
        """将控件填充到给定的单列QFormLayout中。"""
        for key, meta in options_meta.items():
            self._add_widget_to_form(form_layout, section_name, key, meta)

    def _add_widget_to_form(self, form_layout: QFormLayout, section_name: str, key: str, meta: dict):
        """辅助方法：创建一个控件并将其添加到表单布局中。"""
        if section_name not in self.editors:
            self.editors[section_name] = {}
            
        widget_type = meta["widget"]
        label_text = meta["label"]
        editor_widget = None

        if widget_type == "lineedit":
            editor_widget = QLineEdit()
        elif widget_type == "spinbox":
            editor_widget = QSpinBox()
            editor_widget.setRange(meta.get("min", 0), meta.get("max", 99999))
        elif widget_type == "combobox":
            editor_widget = QComboBox()
            editor_widget.addItems(meta["items"])
            editor_widget.setMaximumWidth(200)

        if editor_widget:
            form_layout.addRow(QLabel(f"{label_text}:"), editor_widget)
            self.editors[section_name][key] = editor_widget

    def _load_settings_to_ui(self):
        logging.info("正在同步全局设置页面UI...")
        for section, options in self.editors.items():
            for key, widget in options.items():
                meta = SETTING_METADATA[section][key]
                # 【修改】使用元数据中的 'default' 作为 fallback
                default_value = meta.get("default")
                if isinstance(default_value, int): default_value = str(default_value)
                
                current_value = self.config_service.get_value(section, key, fallback=default_value)

                if isinstance(widget, QLineEdit):
                    widget.setText(current_value)
                elif isinstance(widget, QSpinBox):
                    # 【修改】确保即使是默认值也能被正确处理
                    widget.setValue(int(current_value) if current_value and current_value.isdigit() else meta.get("min", 0))
                elif isinstance(widget, QComboBox):
                    if "map" in meta:
                        display_text = next((text for text, val in meta["map"].items() if val == str(current_value)), None)
                        # 如果找不到映射，尝试直接匹配文本
                        if display_text is None and current_value in meta["items"]:
                            display_text = current_value
                        # 如果还找不到，就用默认值的映射
                        if display_text is None:
                            display_text = next((text for text, val in meta["map"].items() if val == str(default_value)), meta["items"][0])
                        widget.setCurrentText(display_text)
                    else:
                        if current_value in meta["items"]:
                            widget.setCurrentText(current_value)
                        else:
                            widget.setCurrentText(str(default_value))

    def eventFilter(self, obj, event: QEvent) -> bool:
        if obj is self and event.type() == QEvent.Type.Show:
            self._load_settings_to_ui()
        return super().eventFilter(obj, event)

    def save_settings(self):
        logging.info("尝试保存所有设置...")
        try:
            for section, options in self.editors.items():
                for key, widget in options.items():
                    meta = SETTING_METADATA[section][key]
                    value = None
                    if isinstance(widget, QLineEdit):
                        value = widget.text()
                    elif isinstance(widget, QSpinBox):
                        value = str(widget.value())
                    elif isinstance(widget, QComboBox):
                        if "map" in meta:
                            value = meta["map"].get(widget.currentText())
                        else:
                            value = widget.currentText()
                    
                    if value is not None:
                        self.config_service.set_option(section, key, value)
            
            if self.config_service.save_config():
                QMessageBox.information(self, "成功", "所有设置已成功保存！\n部分设置（如日志级别）需要重启应用才能生效。")
            else:
                QMessageBox.warning(self, "失败", "保存设置时发生错误，请查看日志。")
        except Exception as e:
            logging.error(f"保存设置时发生未知错误: {e}", exc_info=True)
            QMessageBox.critical(self, "严重错误", f"保存设置时发生严重错误: {e}")

```

## tray_manager.py

```python
# desktop_center/src/utils/tray_manager.py
import logging
from PySide6.QtCore import QObject, Signal
from PySide6.QtWidgets import QApplication
from PySide6.QtGui import QIcon
from pystray import MenuItem, Icon
from PIL import Image

class TrayManager(QObject):
    """
    负责管理系统托盘图标及其菜单。
    这是一个独立的组件，控制着应用的显示、隐藏和退出逻辑。
    """
    quit_requested = Signal()

    def __init__(self, app: QApplication, window: 'MainWindow', icon_path: str):
        """
        初始化托盘管理器。

        Args:
            app (QApplication): Qt应用程序实例，用于安全退出。
            window (MainWindow): 主窗口实例，用于控制其显示/隐藏。
            icon_path (str): 图标文件的路径。

        Raises:
            FileNotFoundError: 如果图标文件不存在。
        """
        super().__init__()
        
        self.app = app
        self.window = window

        self.window.setWindowIcon(QIcon(icon_path))
        
        try:
            image = Image.open(icon_path)
        except FileNotFoundError:
            raise FileNotFoundError(f"Icon file not found at: {icon_path}")

        menu = (
            MenuItem('显示主窗口', self.show_window, default=True),
            MenuItem('退出程序', self.quit_app)
        )
        
        self.tray_icon = Icon("DesktopCenter", image, "桌面控制与监控中心", menu)
        
        logging.info("系统托盘管理器初始化完成。")

    def run(self) -> None:
        """
        在后台线程中启动托盘图标的事件监听，并增加异常处理。
        """
        try:
            self.tray_icon.run_detached()
            logging.info("系统托盘图标已在独立线程中运行。")
        except Exception as e:
            # 捕获 pystray 启动时可能发生的任何错误 (例如在无头服务器上)
            logging.critical(f"启动系统托盘图标失败: {e}", exc_info=True)
            self.quit_requested.emit()

    def stop_icon(self) -> None:
        """【新增】停止pystray图标的公共方法，由应用协调器调用。"""
        if self.tray_icon.visible:
            self.tray_icon.stop()
            logging.info("pystray图标已停止。")

    def show_window(self) -> None:
        """从托盘菜单显示并激活主窗口。"""
        logging.info("通过托盘菜单请求显示主窗口。")
        self.window.show()
        self.window.activateWindow()

    def quit_app(self) -> None:
        """
        【变更】安全地请求退出整个应用程序。
        此方法现在只负责发出信号，将实际的关闭操作完全委托给应用协调器。
        """
        logging.info("通过托盘菜单请求退出应用程序...")
        
        # 【变更】移除此处的stop调用，关闭操作由ApplicationOrchestrator.shutdown统一处理。
        # self.tray_icon.stop()
        
        logging.info("正在发射信号以触发应用程序的优雅关闭流程...")
        self.quit_requested.emit()
```

## exception_handler.py

```python
# desktop_center/src/utils/exception_handler.py
import sys
import logging
import traceback
from PySide6.QtWidgets import QMessageBox

def global_exception_hook(exctype, value, tb):
    """
    全局异常处理钩子。当任何线程中出现未被捕获的异常时，此函数将被调用。
    """
    # 格式化异常信息
    traceback_details = "".join(traceback.format_exception(exctype, value, tb))
    
    # 记录致命错误日志
    logging.critical(f"捕获到未处理的全局异常:\n{traceback_details}")

    # 准备向用户显示的消息
    error_message = (
        "应用程序遇到了一个严重错误，需要关闭。\n\n"
        "我们对此造成的不便深表歉意。\n\n"
        f"错误类型: {exctype.__name__}\n"
        f"错误信息: {value}\n\n"
        "详细信息已记录到 app.log 文件中，请联系技术支持。"
    )

    # 显示一个阻塞的错误消息框
    # 注意: 这个QMessageBox是在异常发生后创建的，可能在非GUI线程中。
    # Qt通常能处理这种情况，但最稳妥的方式是确保它在主线程显示。
    # 在这个简单场景下，直接显示通常是可行的。
    error_box = QMessageBox()
    error_box.setIcon(QMessageBox.Icon.Critical)
    error_box.setWindowTitle("应用程序严重错误")
    error_box.setText(error_message)
    error_box.setStandardButtons(QMessageBox.StandardButton.Ok)
    error_box.exec()

    # 退出应用程序
    sys.exit(1)

def setup_exception_handler():
    """设置全局异常钩子。"""
    sys.excepthook = global_exception_hook
    logging.info("全局异常处理器已设置。")
```



## program-launcher
### plugin.py
```python
# desktop_center/src/features/program_launcher/plugin.py
import logging
from src.core.plugin_interface import IFeaturePlugin
from src.core.context import ApplicationContext

# 导入插件内部的MVC组件
from .controllers.launcher_controller import LauncherController
from .models.launcher_model import LauncherModel
from .views.launcher_page_view import LauncherPageView

class ProgramLauncherPlugin(IFeaturePlugin):
    """
    程序启动器插件，提供管理和快速启动应用程序的功能。
    """
    
    def name(self) -> str:
        """返回插件的唯一内部名称。"""
        return "program_launcher"

    def display_name(self) -> str:
        """返回插件在UI上显示的名称。"""
        return "程序启动器"
        
    def load_priority(self) -> int:
        """返回插件的加载优先级。"""
        return 100 # 普通独立功能插件

    def initialize(self, context: ApplicationContext):
        """
        初始化插件，创建并连接MVC组件。
        """
        super().initialize(context)
        logging.info(f"[{self.name()}]-> 插件初始化开始...")

        # 1. 创建模型，并将ConfigService注入，以实现路径配置化
        # 【修改】将 context.config_service 传递给模型
        self.model = LauncherModel(config_service=context.config_service)

        # 2. 创建视图
        self.view = LauncherPageView()

        # 3. 创建控制器，将模型和视图注入
        self.controller = LauncherController(self.model, self.view, context)

        # 4. 将视图（主页面）设置为插件的UI页面
        self.page_widget = self.view
        
        logging.info(f"[{self.name()}]-> 插件初始化完成。")

    def shutdown(self):
        """
        在应用程序关闭时，确保数据被保存。
        """
        logging.info(f"[{self.name()}]-> 插件关闭，正在保存数据...")
        if hasattr(self, 'model'):
            self.model.save_data()
        super().shutdown()
        logging.info(f"[{self.name()}]-> 插件已关闭。")
```
### launcher_controller.py
```python
# desktop_center/src/features/program_launcher/controllers/launcher_controller.py
import logging
import os
import subprocess
import sys
from PySide6.QtWidgets import QFileDialog, QMessageBox, QDialog
from PySide6.QtCore import QObject, Slot

from ..models.launcher_model import LauncherModel
from ..views.launcher_page_view import LauncherPageView
from ..widgets.group_dialog import GroupDialog
from ..widgets.delete_group_dialog import DeleteGroupDialog
from ..widgets.add_program_dialog import AddProgramDialog
from src.core.context import ApplicationContext

class LauncherController(QObject):
    def __init__(self, model: LauncherModel, view: LauncherPageView, context: ApplicationContext, parent=None):
        super().__init__(parent)
        self.model = model
        self.view = view
        self.context = context
        self._connect_signals()
        self.refresh_view()

    def _connect_signals(self):
        self.view.add_group_requested.connect(self.add_group)
        self.view.add_program_requested.connect(self.handle_add_program_request)
        self.view.item_double_clicked.connect(self.launch_program)
        self.view.edit_item_requested.connect(self.edit_item)
        self.view.delete_item_requested.connect(self.delete_item)
        self.view.search_text_changed.connect(self.filter_view)
        self.view.change_data_path_requested.connect(self.change_data_path)
        self.view.items_moved.connect(self.handle_items_moved)
        self.view.program_dropped.connect(self.handle_program_drop)
        self.view.group_order_changed.connect(self.model.reorder_groups) # 【新增】连接新信号
        self.model.data_changed.connect(self.refresh_view)

    # ... 其他方法基本保持不变 ...
    def refresh_view(self):
        logging.info("[CONTROLLER] Refreshing view from model data.")
        self.view.rebuild_ui(self.model.get_all_data())
    @Slot()
    def handle_items_moved(self):
        logging.info("[CONTROLLER] Slot 'handle_items_moved' was called. Synchronizing model.")
        new_structure = self.view.get_current_structure()
        self.model.update_full_structure(new_structure)
    @Slot(str, str, int)
    def handle_program_drop(self, program_id: str, target_group_id: str, target_index: int):
        logging.info(f"[CONTROLLER] Handling program drop: prog_id={program_id}, group_id={target_group_id}, index={target_index}")
        self.model.move_program(program_id, target_group_id, target_index)
    @Slot()
    def add_group(self):
        dialog = GroupDialog(self.view)
        if dialog.exec():
            group_name = dialog.get_group_name()
            if group_name: self.model.add_group(group_name)
    @Slot(str)
    def handle_add_program_request(self, group_id: str = None):
        all_groups = self.model.get_all_data().get('groups', [])
        if not all_groups:
            reply = QMessageBox.information(self.view, "需要分组", "目前没有程序分组，请先创建一个。",
                                            QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Ok: self.add_group()
            return
        dialog = AddProgramDialog(all_groups, default_group_id=group_id, parent=self.view)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            details = dialog.get_program_details()
            if details:
                gid, name, path = details
                self.model.add_program(gid, name, path)
    @Slot(str)
    def launch_program(self, program_id: str):
        program = self.model.get_program_by_id(program_id)
        if program and os.path.exists(program['path']):
            try:
                subprocess.Popen(program['path'])
                self.context.notification_service.show(
                    title="程序已启动", message=f"{program['name']} 正在启动。"
                )
            except Exception as e:
                QMessageBox.critical(self.view, "启动失败", f"无法启动程序：\n{program['path']}\n\n错误: {e}")
        else:
            QMessageBox.warning(self.view, "启动失败", "程序路径不存在或已被移动，请编辑或删除此条目。")
    @Slot(str, str)
    def edit_item(self, item_id: str, item_type: str):
        if item_type == 'group':
            group = self.model.get_group_by_id(item_id)
            if not group: return
            dialog = GroupDialog(self.view, current_name=group['name'])
            if dialog.exec():
                new_name = dialog.get_group_name()
                if new_name and new_name != group['name']: self.model.edit_group(item_id, new_name)
        elif item_type == 'program':
            program_to_edit = self.model.get_program_by_id(item_id)
            if not program_to_edit: return
            all_groups = self.model.get_all_data().get('groups', [])
            dialog = AddProgramDialog(all_groups, program_to_edit=program_to_edit, parent=self.view)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                new_group_id, new_name, new_path = dialog.get_program_details()
                self.model.edit_program(item_id, new_group_id, new_name, new_path)
    @Slot(str, str)
    def delete_item(self, item_id: str, item_type: str):
        if item_type == 'group': self._handle_delete_group(item_id)
        elif item_type == 'program':
            program = self.model.get_program_by_id(item_id)
            if not program: return
            reply = QMessageBox.question(self.view, "确认删除", f"您确定要删除程序 '{program['name']}' 吗？",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes: self.model.delete_program(item_id)
    def _handle_delete_group(self, group_id: str):
        group = self.model.get_group_by_id(group_id)
        if not group: return
        other_groups = self.model.get_other_groups(group_id)
        programs_in_group = self.model.get_programs_in_group(group_id)
        if not programs_in_group:
            reply = QMessageBox.question(self.view, "确认删除", f"您确定要删除空分组 '{group['name']}' 吗？",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes: self.model.delete_group(group_id)
            return
        dialog = DeleteGroupDialog(group['name'], other_groups, self.view)
        if dialog.exec():
            choice, target_group_id = dialog.get_result()
            if choice == 'move':
                if not target_group_id and not other_groups:
                    target_group_id = self.model.add_group("默认分组")
                self.model.move_programs_to_group(group_id, target_group_id)
                self.model.delete_group(group_id)
            elif choice == 'delete_all':
                self.model.delete_group(group_id, delete_programs=True)
    @Slot(str)
    def filter_view(self, text: str):
        if hasattr(self.view, 'filter_items'): self.view.filter_items(text)
    @Slot()
    def change_data_path(self):
        current_path = self.model.data_file
        new_path, _ = QFileDialog.getOpenFileName(
            self.view, "选择或指定程序启动器数据文件",
            os.path.dirname(current_path), "JSON 文件 (*.json);;所有文件 (*)"
        )
        if new_path and new_path != current_path:
            try:
                self.model.set_data_path(new_path)
                QMessageBox.information(
                    self.view, "成功", f"数据源已成功切换到:\n{new_path}\n\n界面已刷新。"
                )
            except Exception as e:
                QMessageBox.critical(
                    self.view, "操作失败", f"无法切换数据源到: {new_path}\n\n设置未更改。"
                )
```
### launcher_model.py
```python
# desktop_center/src/features/program_launcher/models/launcher_model.py
import json
import logging
import os
import uuid
from PySide6.QtCore import QObject, Signal

from src.services.config_service import ConfigService

CONFIG_SECTION = "ProgramLauncher"

class LauncherModel(QObject):
    data_changed = Signal()

    def __init__(self, config_service: ConfigService, parent=None):
        super().__init__(parent)
        self.config_service = config_service
        default_path = "launcher_data.json"
        self.data_file = self.config_service.get_value(CONFIG_SECTION, "data_file_path", default_path)
        self.data = {"groups": [], "programs": {}}
        self.load_data()

    def load_data(self):
        try:
            if os.path.exists(self.data_file):
                with open(self.data_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    if not content: self.data = {"groups": [], "programs": {}}
                    else: self.data = json.loads(content)
                    if "groups" not in self.data: self.data["groups"] = []
                    if "programs" not in self.data: self.data["programs"] = {}
                logging.info(f"已从 {self.data_file} 加载启动器数据。")
            else:
                logging.warning(f"启动器数据文件 {self.data_file} 不存在，将视为空配置。")
                self.data = {"groups": [], "programs": {}}
        except (json.JSONDecodeError, IOError) as e:
            logging.error(f"加载启动器数据文件 {self.data_file} 失败: {e}")
            self.data = {"groups": [], "programs": {}}
            raise e

    def save_data(self):
        try:
            logging.info(f"[MODEL] Saving data to {self.data_file}...")
            dir_name = os.path.dirname(self.data_file)
            if dir_name: os.makedirs(dir_name, exist_ok=True)
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, indent=4, ensure_ascii=False)
            logging.info(f"启动器数据已成功保存到 {self.data_file}。")
        except IOError as e:
            logging.error(f"保存启动器数据到 {self.data_file} 失败: {e}")
            
    def set_data_path(self, new_path: str):
        if new_path == self.data_file: return
        self.config_service.set_option(CONFIG_SECTION, "data_file_path", new_path)
        self.config_service.save_config()
        self.data_file = new_path
        try:
            self.load_data()
            self.data_changed.emit()
        except Exception:
            raise

    def update_full_structure(self, new_structure: dict):
        logging.info("[MODEL] Updating full data structure based on UI.")
        self.data = new_structure
        self.save_data()
        self.data_changed.emit()

    def get_all_data(self):
        return json.loads(json.dumps(self.data))

    def add_group(self, name: str) -> str:
        new_group = {"id": str(uuid.uuid4()), "name": name}
        self.data["groups"].append(new_group)
        self.save_data()
        self.data_changed.emit()
        return new_group["id"]

    def edit_group(self, group_id: str, new_name: str):
        for group in self.data["groups"]:
            if group["id"] == group_id:
                group["name"] = new_name
                self.save_data()
                self.data_changed.emit()
                return

    def reorder_groups(self, group_ids: list[str]):
        """【核心修复】恢复被误删的方法，用于处理分组排序。"""
        if not group_ids: return
        
        group_map = {g['id']: g for g in self.data['groups']}
        
        # 过滤掉可能不存在的ID，并按新顺序重组
        new_groups_order = [group_map[gid] for gid in group_ids if gid in group_map]
        
        # 如果新旧列表长度不一致，说明有ID丢失，为安全起见不更新
        if len(new_groups_order) == len(self.data['groups']):
            self.data['groups'] = new_groups_order
            self.save_data()
            self.data_changed.emit()
            logging.info("Group order has been updated.")
        else:
            logging.warning("Group reorder failed due to ID mismatch.")


    def delete_group(self, group_id: str, delete_programs: bool = False):
        self.data["groups"] = [g for g in self.data["groups"] if g["id"] != group_id]
        if delete_programs:
            self.data["programs"] = {pid: p for pid, p in self.data["programs"].items() if p["group_id"] != group_id}
        self.save_data()
        self.data_changed.emit()

    def add_program(self, group_id: str, name: str, path: str):
        program_id = str(uuid.uuid4())
        self.data["programs"][program_id] = {
            "id": program_id, "group_id": group_id, "name": name, "path": path,
            "order": len(self.get_programs_in_group(group_id))
        }
        self.save_data()
        self.data_changed.emit()

    def edit_program(self, program_id: str, new_group_id: str, new_name: str, new_path: str):
        if program_id in self.data['programs']:
            program = self.data['programs'][program_id]
            # 如果分组发生了变化，需要调整两个分组的order
            if program['group_id'] != new_group_id:
                self.move_program(program_id, new_group_id, 9999) # 移动到新分组末尾
            program['group_id'] = new_group_id
            program['name'] = new_name
            program['path'] = new_path
            self.save_data()
            self.data_changed.emit()
            logging.info(f"程序已编辑: ID={program_id}, Name={new_name}")

    def delete_program(self, program_id: str):
        program_to_delete = self.data['programs'].pop(program_id, None)
        if not program_to_delete: return
        
        # 重新计算被删除程序所在分组的 order
        group_id = program_to_delete['group_id']
        remaining_progs = self.get_programs_in_group(group_id)
        for i, p in enumerate(remaining_progs):
            p['order'] = i
        
        self.save_data()
        self.data_changed.emit()
            
    def get_program_by_id(self, program_id: str) -> dict | None:
        return self.data["programs"].get(program_id)
        
    def get_group_by_id(self, group_id: str) -> dict | None:
        for group in self.data["groups"]:
            if group["id"] == group_id: return group
        return None

    def get_programs_in_group(self, group_id: str) -> list:
        programs = [p for p in self.data["programs"].values() if p.get('group_id') == group_id]
        programs.sort(key=lambda p: p.get("order", 0))
        return programs
        
    def get_other_groups(self, group_id_to_exclude: str) -> list:
        return [g for g in self.data["groups"] if g["id"] != group_id_to_exclude]

    def move_programs_to_group(self, old_group_id: str, new_group_id: str):
        for program in self.data["programs"].values():
            if program["group_id"] == old_group_id:
                program["group_id"] = new_group_id

    def move_program(self, program_id: str, target_group_id: str, target_index: int):
        """移动一个程序到新的位置（组内或跨组）。"""
        program = self.data['programs'].get(program_id)
        if not program: return
            
        source_group_id = program['group_id']
        
        # 从源数据中分离出所有相关程序
        source_group_progs = self.get_programs_in_group(source_group_id)
        target_group_progs = self.get_programs_in_group(target_group_id) if source_group_id != target_group_id else source_group_progs
        
        moved_program = None
        for p in source_group_progs:
            if p['id'] == program_id:
                moved_program = p
                break
        if moved_program:
            source_group_progs.remove(moved_program)
        
        moved_program['group_id'] = target_group_id

        if source_group_id != target_group_id:
             target_group_progs.insert(target_index, moved_program)
        else:
             source_group_progs.insert(target_index, moved_program)
        
        for i, p in enumerate(source_group_progs):
            self.data['programs'][p['id']]['order'] = i
            
        if source_group_id != target_group_id:
            for i, p in enumerate(target_group_progs):
                self.data['programs'][p['id']]['order'] = i
            
        self.save_data()
        self.data_changed.emit()
```
### launcher_page_view.py
```python
# desktop_center/src/features/program_launcher/views/launcher_page_view.py
import logging
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QPushButton, QHBoxLayout, 
                               QLineEdit, QSpacerItem, QSizePolicy, QStackedWidget, QButtonGroup)
from PySide6.QtCore import Signal
from PySide6.QtGui import QIcon

from .modes.base_view import BaseViewMode
from .modes.tree_view import TreeViewMode
from .modes.icon_view import IconViewMode

class LauncherPageView(QWidget):
    # ... 信号定义保持不变 ...
    add_group_requested = Signal()
    add_program_requested = Signal(str)
    item_double_clicked = Signal(str)
    edit_item_requested = Signal(str, str)
    delete_item_requested = Signal(str, str)
    search_text_changed = Signal(str)
    change_data_path_requested = Signal()
    items_moved = Signal()
    program_dropped = Signal(str, str, int)
    group_order_changed = Signal(list)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.data_cache = {}
        self._init_ui()
        self.tree_view.update_view({})

    def _init_ui(self):
        # ... UI创建部分保持不变 ...
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        toolbar_layout = QHBoxLayout()
        self.add_group_btn = QPushButton(QIcon.fromTheme("list-add"), " 新建分组")
        self.add_program_btn = QPushButton(QIcon.fromTheme("document-new"), " 添加程序")
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("搜索程序...")
        self.settings_btn = QPushButton()
        self.settings_btn.setIcon(QIcon.fromTheme("emblem-system"))
        self.settings_btn.setToolTip("设置数据文件路径")
        self.view_mode_group = QButtonGroup(self)
        self.tree_view_btn = QPushButton(QIcon.fromTheme("view-list-tree"), "")
        self.tree_view_btn.setToolTip("树状视图")
        self.tree_view_btn.setCheckable(True)
        self.icon_view_btn = QPushButton(QIcon.fromTheme("view-grid"), "")
        self.icon_view_btn.setToolTip("图标视图")
        self.icon_view_btn.setCheckable(True)
        self.view_mode_group.addButton(self.tree_view_btn, 0)
        self.view_mode_group.addButton(self.icon_view_btn, 1)
        self.tree_view_btn.setChecked(True)
        toolbar_layout.addWidget(self.add_group_btn)
        toolbar_layout.addWidget(self.add_program_btn)
        toolbar_layout.addSpacerItem(QSpacerItem(20, 20, QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum))
        toolbar_layout.addWidget(self.search_bar)
        toolbar_layout.addWidget(self.tree_view_btn)
        toolbar_layout.addWidget(self.icon_view_btn)
        toolbar_layout.addWidget(self.settings_btn)
        layout.addLayout(toolbar_layout)
        self.stacked_widget = QStackedWidget()
        self.tree_view = TreeViewMode()
        self.icon_view = IconViewMode()
        self.stacked_widget.addWidget(self.tree_view)
        self.stacked_widget.addWidget(self.icon_view)
        layout.addWidget(self.stacked_widget)
        
        # 连接信号
        self.add_group_btn.clicked.connect(self.add_group_requested)
        self.add_program_btn.clicked.connect(lambda: self.add_program_requested.emit(None))
        self.settings_btn.clicked.connect(self.change_data_path_requested)
        # 【修改】连接到自身的 filter_items 方法
        self.search_bar.textChanged.connect(self.filter_items)
        self.view_mode_group.idClicked.connect(self.stacked_widget.setCurrentIndex)
        self.stacked_widget.currentChanged.connect(self.on_view_mode_changed)
        self._connect_view_signals(self.tree_view)
        self._connect_view_signals(self.icon_view)

    def _connect_view_signals(self, view: BaseViewMode):
        view.item_double_clicked.connect(self.item_double_clicked)
        view.edit_item_requested.connect(self.edit_item_requested)
        view.delete_item_requested.connect(self.delete_item_requested)
        view.items_moved.connect(self.items_moved)
        view.program_dropped.connect(self.program_dropped)
        view.add_program_to_group_requested.connect(self.add_program_requested)
        view.group_order_changed.connect(self.group_order_changed)

    def rebuild_ui(self, data: dict):
        self.data_cache = data
        # 【修改】刷新时，同时更新两个视图的数据，并应用当前搜索
        current_search = self.search_bar.text()
        self.tree_view.update_view(data)
        self.icon_view.update_view(data)
        if current_search:
            self.filter_items(current_search)

    def on_view_mode_changed(self, index: int):
        # 切换视图时，数据已经是新的，只需要应用搜索即可
        self.filter_items(self.search_bar.text())

    def get_current_structure(self) -> dict:
        active_view = self.stacked_widget.currentWidget()
        if hasattr(active_view, 'get_current_structure'):
            return active_view.get_current_structure()
        return self.data_cache

    def filter_items(self, text: str):
        """将过滤请求分发到所有视图模式。"""
        self.tree_view.filter_items(text)
        self.icon_view.filter_items(text)
```
### base_view.py
```python
# desktop_center/src/features/program_launcher/views/modes/base_view.py
from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Signal

class BaseViewMode(QWidget):
    item_double_clicked = Signal(str)
    edit_item_requested = Signal(str, str)
    delete_item_requested = Signal(str, str)
    add_program_to_group_requested = Signal(str)
    items_moved = Signal() # 用于树状视图
    program_dropped = Signal(str, str, int) # 用于图标视图的程序卡片
    group_order_changed = Signal(list) # 【新增】用于图标视图的分组排序

    def __init__(self, parent=None):
        super().__init__(parent)

    def update_view(self, data: dict):
        raise NotImplementedError("Subclasses of BaseViewMode must implement the 'update_view' method.")
```
### flow_layout.py
```python
# desktop_center/src/features/program_launcher/views/modes/flow_layout.py
# Copyright (C) 2013 Riverbank Computing Limited.
# Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
# All rights reserved.
#
# This file is part of the examples of PyQt.
#
# $QT_BEGIN_LICENSE:BSD$
# You may use this file under the terms of the BSD license as follows:
#
# "Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
#   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
#     the names of its contributors may be used to endorse or promote
#     products derived from this software without specific prior written
#     permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, or TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
# $QT_END_LICENSE$

from PySide6.QtCore import QPoint, QRect, QSize, Qt
from PySide6.QtWidgets import QLayout, QSizePolicy, QSpacerItem

class FlowLayout(QLayout):
    def __init__(self, parent=None, margin=-1, h_spacing=-1, v_spacing=-1):
        super(FlowLayout, self).__init__(parent)
        if margin != -1:
            self.setContentsMargins(margin, margin, margin, margin)
        self.h_spacing = h_spacing
        self.v_spacing = v_spacing
        self.item_list = []

    def __del__(self):
        item = self.takeAt(0)
        while item:
            item = self.takeAt(0)

    def addItem(self, item):
        self.item_list.append(item)

    def count(self):
        return len(self.item_list)

    def itemAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list.pop(index)
        return None

    def expandingDirections(self):
        return Qt.Orientation(0)

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        height = self._do_layout(QRect(0, 0, width, 0), True)
        return height

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self._do_layout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QSize()
        for item in self.item_list:
            size = size.expandedTo(item.minimumSize())
        margin, _, _, _ = self.getContentsMargins()
        size += QSize(2 * margin, 2 * margin)
        return size

    def _do_layout(self, rect, test_only):
        x = rect.x()
        y = rect.y()
        line_height = 0
        spacing = self.spacing()
        if spacing == -1:
            spacing = self.style().layoutSpacing(QSizePolicy.ControlType.PushButton, QSizePolicy.ControlType.PushButton, Qt.Orientation.Horizontal)
        
        h_spacing = self.h_spacing if self.h_spacing >= 0 else spacing
        v_spacing = self.v_spacing if self.v_spacing >= 0 else spacing

        for item in self.item_list:
            next_x = x + item.sizeHint().width() + h_spacing
            if next_x - h_spacing > rect.right() and line_height > 0:
                x = rect.x()
                y = y + line_height + v_spacing
                next_x = x + item.sizeHint().width() + h_spacing
                line_height = 0
            if not test_only:
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))
            x = next_x
            line_height = max(line_height, item.sizeHint().height())
        return y + line_height - rect.y()
```
### icon_view.py
```python
# desktop_center/src/features/program_launcher/views/modes/icon_view.py
import logging
from PySide6.QtWidgets import (QMenu, QFileIconProvider, QVBoxLayout, 
                               QLabel, QWidget, QScrollArea, QFrame)
from PySide6.QtGui import QIcon, QDragEnterEvent, QDropEvent, QDragMoveEvent
from PySide6.QtCore import Qt, QFileInfo, QPoint, QRect

from .base_view import BaseViewMode
from ...widgets.card_widget import CardWidget
from ...widgets.group_header_widget import GroupHeaderWidget
from .flow_layout import FlowLayout

class IconViewMode(BaseViewMode):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.icon_cache = {}; self.icon_provider = QFileIconProvider()
        self.card_containers = {}; self.group_headers = {}
        
        main_layout = QVBoxLayout(self); main_layout.setContentsMargins(0, 0, 0, 0)
        scroll_area = QScrollArea(); scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QScrollArea.Shape.NoFrame)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        self.content_widget = QWidget()
        scroll_area.setWidget(self.content_widget)

        self.content_layout = QVBoxLayout(self.content_widget)
        self.content_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        
        main_layout.addWidget(scroll_area)
        
        self.drop_indicator = QFrame(self.content_widget)
        self.drop_indicator.setLineWidth(2); self.drop_indicator.hide()
        
        self.setAcceptDrops(True)

    def update_view(self, data: dict):
        self.card_containers.clear(); self.group_headers.clear()
        while self.content_layout.count():
            child = self.content_layout.takeAt(0)
            if child.widget(): child.widget().deleteLater()

        groups = data.get("groups", []); programs = data.get("programs", {})
        programs_by_group = {}
        for prog_id, prog_data in programs.items():
            group_id = prog_data.get('group_id')
            if group_id not in programs_by_group: programs_by_group[group_id] = []
            programs_by_group[group_id].append(prog_data)
        for group_id in programs_by_group:
            programs_by_group[group_id].sort(key=lambda p: p.get("order", 0))

        if not groups:
            self.content_layout.addWidget(QLabel("没有内容，请先添加分组和程序。"))
            return

        for group_data in groups:
            group_header = GroupHeaderWidget(group_data)
            group_header.customContextMenuRequested.connect(self._on_group_context_menu)
            self.content_layout.addWidget(group_header)
            self.group_headers[group_data['id']] = group_header

            card_container = QWidget()
            flow_layout = FlowLayout(card_container, h_spacing=10, v_spacing=10)
            self.card_containers[group_data['id']] = card_container

            programs_in_group = programs_by_group.get(group_data['id'], [])
            if not programs_in_group:
                flow_layout.addWidget(QLabel("(此分组为空)"))
            else:
                for prog_data in programs_in_group:
                    icon = self._get_program_icon(prog_data['path'])
                    card = CardWidget(prog_data, icon)
                    card.doubleClicked.connect(self.item_double_clicked)
                    card.customContextMenuRequested.connect(self._on_card_context_menu)
                    flow_layout.addWidget(card)
            
            self.content_layout.addWidget(card_container)
        self.content_layout.addStretch()

    def filter_items(self, text: str):
        text = text.lower()
        for group_id, header in self.group_headers.items():
            container = self.card_containers.get(group_id)
            if not container: continue
            group_name = header.title_label.text().lower()
            group_has_visible_child = False
            layout = container.layout()
            for i in range(layout.count()):
                widget = layout.itemAt(i).widget()
                if isinstance(widget, CardWidget):
                    card_name = widget.name_label.text().lower()
                    is_match = text in card_name
                    widget.setVisible(is_match)
                    if is_match: group_has_visible_child = True
            group_is_match = text in group_name
            header.setVisible(group_has_visible_child or group_is_match)
            container.setVisible(group_has_visible_child or group_is_match)
            
    def _get_program_icon(self, path: str):
        if not path or path in self.icon_cache: return self.icon_cache.get(path, QIcon.fromTheme("application-x-executable"))
        icon = self.icon_provider.icon(QFileInfo(path))
        if icon.isNull(): icon = QIcon.fromTheme("application-x-executable")
        self.icon_cache[path] = icon
        return icon

    def _on_card_context_menu(self, program_id, event):
        menu = QMenu(self)
        menu.addAction("启动").triggered.connect(lambda: self.item_double_clicked.emit(program_id))
        menu.addAction("编辑...").triggered.connect(lambda: self.edit_item_requested.emit(program_id, 'program'))
        menu.addAction("删除").triggered.connect(lambda: self.delete_item_requested.emit(program_id, 'program'))
        menu.exec_(event.globalPos())

    def _on_group_context_menu(self, group_id, event):
        menu = QMenu(self)
        menu.addAction("添加程序到此分组...").triggered.connect(lambda: self.add_program_to_group_requested.emit(group_id))
        menu.addSeparator()
        menu.addAction("重命名分组").triggered.connect(lambda: self.edit_item_requested.emit(group_id, 'group'))
        menu.addAction("删除分组").triggered.connect(lambda: self.delete_item_requested.emit(group_id, 'group'))
        menu.exec_(event.globalPos())

    def dragEnterEvent(self, event: QDragEnterEvent):
        if event.mimeData().hasFormat("application/x-program-launcher-card") or \
           event.mimeData().hasFormat("application/x-program-launcher-group"):
            event.acceptProposedAction()
        else: event.ignore()

    def dragLeaveEvent(self, event):
        self.drop_indicator.hide()

    def dragMoveEvent(self, event: QDragMoveEvent):
        pos = self.content_widget.mapFrom(self, event.position().toPoint())
        
        if event.mimeData().hasFormat("application/x-program-launcher-card"):
            self.drop_indicator.setFrameShape(QFrame.Shape.VLine)
            target_group_id, target_index, indicator_pos = self._find_card_drop_pos(pos)
        elif event.mimeData().hasFormat("application/x-program-launcher-group"):
            self.drop_indicator.setFrameShape(QFrame.Shape.HLine)
            target_index, indicator_pos = self._find_group_drop_pos(pos)
        else:
            event.ignore(); return
        
        if indicator_pos:
            self.drop_indicator.setGeometry(indicator_pos)
            self.drop_indicator.show(); event.accept()
        else:
            self.drop_indicator.hide()

    def dropEvent(self, event: QDropEvent):
        self.drop_indicator.hide()
        pos = self.content_widget.mapFrom(self, event.position().toPoint())
        
        if event.mimeData().hasFormat("application/x-program-launcher-card"):
            program_id = event.mimeData().data("application/x-program-launcher-card").data().decode('utf-8')
            target_group_id, target_index, _ = self._find_card_drop_pos(pos)
            if target_group_id is not None and program_id:
                self.program_dropped.emit(program_id, target_group_id, target_index)
                event.acceptProposedAction()
        elif event.mimeData().hasFormat("application/x-program-launcher-group"):
            source_group_id = event.mimeData().data("application/x-program-launcher-group").data().decode('utf-8')
            target_index, _ = self._find_group_drop_pos(pos)
            
            group_ids = list(self.group_headers.keys())
            if source_group_id in group_ids and target_index is not None:
                group_ids.remove(source_group_id)
                group_ids.insert(target_index, source_group_id)
                self.group_order_changed.emit(group_ids)
                event.acceptProposedAction()
        else: event.ignore()

    def _find_card_drop_pos(self, pos_in_content_widget: QPoint):
        for group_id, container in self.card_containers.items():
            if container.geometry().contains(pos_in_content_widget):
                layout = container.layout()
                local_pos = container.mapFrom(self.content_widget, pos_in_content_widget)
                target_index = 0
                for i in range(layout.count()):
                    widget = layout.itemAt(i).widget()
                    if isinstance(widget, CardWidget):
                        if local_pos.x() < widget.geometry().center().x(): break
                        target_index = i + 1
                
                rect = QRect()
                if layout.count() == 0 or not isinstance(layout.itemAt(0).widget(), CardWidget):
                    rect.setRect(5, 5, 2, 80)
                elif target_index < layout.count():
                    widget = layout.itemAt(target_index).widget()
                    rect.setRect(widget.x() - 5, widget.y(), 2, widget.height())
                else:
                    last_widget = layout.itemAt(layout.count() - 1).widget()
                    rect.setRect(last_widget.x() + last_widget.width() + 3, last_widget.y(), 2, last_widget.height())
                
                final_rect = QRect(container.mapTo(self.content_widget, rect.topLeft()), rect.size())
                return group_id, target_index, final_rect
        return None, -1, None
    
    def _find_group_drop_pos(self, pos_in_content_widget: QPoint):
        target_index = 0
        sorted_headers = sorted(self.group_headers.values(), key=lambda h: h.y())

        for i, header in enumerate(sorted_headers):
            container = self.card_containers[header.group_id]
            group_rect = header.geometry().united(container.geometry())
            if pos_in_content_widget.y() < group_rect.center().y():
                break
            target_index = i + 1
        
        rect = QRect()
        if not sorted_headers: return None, None
        
        if target_index < len(sorted_headers):
            header = sorted_headers[target_index]
            rect.setRect(header.x(), header.y() - 5, header.width(), 2)
        else:
            last_header = sorted_headers[-1]
            last_container = self.card_containers[last_header.group_id]
            rect.setRect(last_header.x(), last_container.y() + last_container.height() + 5, last_header.width(), 2)
            
        return target_index, rect
```
### tree_view.py
```python
# desktop_center/src/features/program_launcher/views/modes/tree_view.py
import logging
import os
from PySide6.QtWidgets import (QTreeWidget, QTreeWidgetItem, QMenu, QAbstractItemView,
                               QFileIconProvider, QVBoxLayout)
from PySide6.QtGui import QIcon, QDropEvent
from PySide6.QtCore import Qt, QFileInfo

from .base_view import BaseViewMode

class LauncherTreeWidget(QTreeWidget):
    """
    专用于树状视图的自定义QTreeWidget，以可靠地处理拖放事件。
    """
    def __init__(self, parent_view: BaseViewMode):
        super().__init__(parent_view)
        self.parent_view = parent_view

    def dropEvent(self, event: QDropEvent):
        source_item = self.currentItem()
        if not source_item:
            event.ignore(); return

        target_item = self.itemAt(event.position().toPoint())
        drop_indicator = self.dropIndicatorPosition()

        source_data = source_item.data(0, Qt.ItemDataRole.UserRole)
        source_type = source_data.get('type')

        # 【核心修复-BUG-1】
        if source_type == 'program':
            # 规则：程序不能成为顶层项目
            # 情况1: 拖到了空白处，目标项为空
            if not target_item:
                logging.warning("[LauncherTreeWidget] Illegal drop: Program cannot be dropped into top-level empty space.")
                event.ignore(); return
            
            # 情况2: 拖到了一个分组的上方或下方，这将使其成为顶层项
            if target_item.parent() is None and drop_indicator != QAbstractItemView.DropIndicatorPosition.OnItem:
                 logging.warning("[LauncherTreeWidget] Illegal drop: Program cannot be dropped between groups.")
                 event.ignore(); return

        if source_type == 'group':
            if drop_indicator == QAbstractItemView.DropIndicatorPosition.OnItem:
                event.ignore(); return
            if target_item and target_item.parent():
                event.ignore(); return
        
        super().dropEvent(event)
        self.parent_view.items_moved.emit()


class TreeViewMode(BaseViewMode):
    """
    树状视图模式的实现。
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.icon_cache = {}
        self.icon_provider = QFileIconProvider()
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        self.tree = LauncherTreeWidget(self)
        self.tree.setHeaderHidden(True)
        self.tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.tree.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)
        self.tree.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.tree.setDragEnabled(True)
        self.tree.setAcceptDrops(True)
        self.tree.setDropIndicatorShown(True)
        
        layout.addWidget(self.tree)

        self.tree.itemDoubleClicked.connect(self._on_item_double_clicked)
        self.tree.customContextMenuRequested.connect(self._on_context_menu)

    def update_view(self, data: dict):
        current_search = self.parent().search_bar.text() if self.parent() and hasattr(self.parent(), 'search_bar') else ""
        
        self.tree.blockSignals(True)
        try:
            self.tree.clear()
            groups = data.get("groups", [])
            programs = data.get("programs", {})
            programs_by_group = {}
            for prog_id, prog_data in programs.items():
                group_id = prog_data.get('group_id')
                if group_id not in programs_by_group: programs_by_group[group_id] = []
                programs_by_group[group_id].append(prog_data)
            for group_id in programs_by_group:
                programs_by_group[group_id].sort(key=lambda p: p.get("order", 0))

            for group_data in groups:
                group_item = QTreeWidgetItem(self.tree, [group_data['name']])
                group_item.setData(0, Qt.ItemDataRole.UserRole, {"id": group_data['id'], "type": "group", "name": group_data['name']})
                group_item.setIcon(0, QIcon.fromTheme("folder"))
                group_item.setFlags(group_item.flags() | Qt.ItemFlag.ItemIsDropEnabled)
                for prog_data in programs_by_group.get(group_data['id'], []):
                    program_item = QTreeWidgetItem(group_item, [prog_data['name']])
                    program_item.setData(0, Qt.ItemDataRole.UserRole, {"id": prog_data['id'], "type": "program", "name": prog_data['name'], "path": prog_data['path']})
                    program_item.setIcon(0, self._get_program_icon(prog_data['path']))
                    program_item.setFlags(program_item.flags() & ~Qt.ItemFlag.ItemIsDropEnabled)
                group_item.setExpanded(True)
        finally:
            self.tree.blockSignals(False)
        
        if current_search:
            self.filter_items(current_search)

    def get_current_structure(self) -> dict:
        new_groups, new_programs = [], {}
        root = self.tree.invisibleRootItem()
        for i in range(root.childCount()):
            group_item = root.child(i)
            group_data = group_item.data(0, Qt.ItemDataRole.UserRole)
            if not isinstance(group_data, dict) or 'id' not in group_data: continue
            group_id = group_data['id']
            new_groups.append({"id": group_id, "name": group_data['name']})
            for j in range(group_item.childCount()):
                program_item = group_item.child(j)
                program_data = program_item.data(0, Qt.ItemDataRole.UserRole)
                if not isinstance(program_data, dict) or 'id' not in program_data: continue
                program_id = program_data['id']
                new_programs[program_id] = {"id": program_id, "group_id": group_id, "name": program_data['name'], "path": program_data['path'], "order": j}
        return {"groups": new_groups, "programs": new_programs}

    def _get_program_icon(self, path: str) -> QIcon:
        if not path or path in self.icon_cache: return self.icon_cache.get(path, QIcon.fromTheme("application-x-executable"))
        icon = self.icon_provider.icon(QFileInfo(path))
        if icon.isNull(): icon = QIcon.fromTheme("application-x-executable")
        self.icon_cache[path] = icon
        return icon

    def _on_item_double_clicked(self, item: QTreeWidgetItem):
        data = item.data(0, Qt.ItemDataRole.UserRole)
        if data and data.get('type') == 'program':
            self.item_double_clicked.emit(data['id'])
            
    def _on_context_menu(self, pos):
        item = self.tree.itemAt(pos)
        if not item: return
        data = item.data(0, Qt.ItemDataRole.UserRole)
        menu = QMenu(self)
        if data.get('type') == 'group':
            menu.addAction("添加程序到此分组...").triggered.connect(lambda: self.add_program_to_group_requested.emit(data['id']))
            menu.addSeparator()
            menu.addAction("重命名分组").triggered.connect(lambda: self.edit_item_requested.emit(data['id'], 'group'))
            menu.addAction("删除分组").triggered.connect(lambda: self.delete_item_requested.emit(data['id'], 'group'))
        elif data.get('type') == 'program':
            menu.addAction("启动").triggered.connect(lambda: self.item_double_clicked.emit(data['id']))
            menu.addAction("编辑...").triggered.connect(lambda: self.edit_item_requested.emit(data['id'], 'program'))
            menu.addAction("删除").triggered.connect(lambda: self.delete_item_requested.emit(data['id'], 'program'))
        menu.exec_(self.tree.mapToGlobal(pos))
        
    def filter_items(self, text: str):
        """【核心修复-BUG-2】为树状视图实现/验证搜索功能。"""
        text = text.lower()
        root = self.tree.invisibleRootItem()
        for i in range(root.childCount()):
            group_item = root.child(i)
            group_data = group_item.data(0, Qt.ItemDataRole.UserRole)
            group_name = group_data.get('name', '').lower()
            
            group_has_visible_child = False
            for j in range(group_item.childCount()):
                program_item = group_item.child(j)
                program_data = program_item.data(0, Qt.ItemDataRole.UserRole)
                program_name = program_data.get('name', '').lower()
                
                is_match = text in program_name
                program_item.setHidden(not is_match)
                if is_match:
                    group_has_visible_child = True
            
            # 如果分组名匹配，或其下有匹配的程序，则显示该分组
            group_is_match = text in group_name
            group_item.setHidden(not (group_has_visible_child or group_is_match))
            
            # 如果在搜索，则展开匹配的分组
            if text:
                group_item.setExpanded(group_has_visible_child or group_is_match)
```
### add_program_dialog.py
```python
# desktop_center/src/features/program_launcher/widgets/add_program_dialog.py
import os
from PySide6.QtWidgets import (QDialog, QVBoxLayout, QLineEdit, QDialogButtonBox, QLabel,
                               QFormLayout, QComboBox, QPushButton, QHBoxLayout, QFileDialog)
from PySide6.QtCore import Slot

class AddProgramDialog(QDialog):
    """
    一个专用的对话框，用于添加新程序或编辑现有程序。
    """
    # 【核心修复】增加 default_group_id 参数以支持快捷添加模式
    def __init__(self, groups: list, program_to_edit: dict = None, default_group_id: str = None, parent=None):
        super().__init__(parent)
        self.is_edit_mode = program_to_edit is not None

        title = "编辑程序" if self.is_edit_mode else "添加新程序"
        self.setWindowTitle(title)
        self.setMinimumWidth(450)

        # -- UI 组件 --
        layout = QFormLayout(self)
        layout.setSpacing(10)

        # 分组选择
        self.group_combo = QComboBox()
        for group in groups:
            self.group_combo.addItem(group['name'], group['id'])
        
        # 程序名称
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("例如：谷歌浏览器")

        # 文件路径
        path_layout = QHBoxLayout()
        self.path_edit = QLineEdit()
        self.path_edit.setReadOnly(True)
        self.path_edit.setPlaceholderText("请选择可执行文件...")
        self.browse_btn = QPushButton("浏览...")
        path_layout.addWidget(self.path_edit)
        path_layout.addWidget(self.browse_btn)

        # 对话框按钮
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        
        # 【核心修复】重构预设值逻辑
        group_id_to_select = None
        if self.is_edit_mode:
            self.name_edit.setText(program_to_edit.get('name', ''))
            self.path_edit.setText(program_to_edit.get('path', ''))
            group_id_to_select = program_to_edit.get('group_id')
        elif default_group_id:
            group_id_to_select = default_group_id
        
        if group_id_to_select:
            index = self.group_combo.findData(group_id_to_select)
            if index != -1:
                self.group_combo.setCurrentIndex(index)
        
        self.ok_button.setEnabled(False)
        self.validate_input()

        layout.addRow(QLabel("所属分组:"), self.group_combo)
        layout.addRow(QLabel("程序名称:"), self.name_edit)
        layout.addRow(QLabel("文件路径:"), path_layout)
        layout.addRow(self.button_box)

        # -- 连接信号 --
        self.browse_btn.clicked.connect(self.browse_file)
        self.name_edit.textChanged.connect(self.validate_input)
        self.path_edit.textChanged.connect(self.validate_input)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)

    @Slot()
    def browse_file(self):
        """打开文件对话框以选择文件。"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "选择一个可执行文件",
            "",
            "可执行文件 (*.exe);;所有文件 (*)"
        )
        if file_path:
            self.path_edit.setText(file_path)
            if not self.name_edit.text() and not self.is_edit_mode:
                program_name = os.path.splitext(os.path.basename(file_path))[0]
                self.name_edit.setText(program_name.replace('_', ' ').title())

    @Slot()
    def validate_input(self):
        """验证输入是否有效，以启用/禁用OK按钮。"""
        name_ok = bool(self.name_edit.text().strip())
        path_ok = bool(self.path_edit.text().strip())
        self.ok_button.setEnabled(name_ok and path_ok)

    def get_program_details(self) -> tuple[str, str, str]:
        """获取用户输入的程序详情。"""
        group_id = self.group_combo.currentData()
        program_name = self.name_edit.text().strip()
        file_path = self.path_edit.text().strip()
        return group_id, program_name, file_path
```
### card_widget.py
```python
# desktop_center/src/features/program_launcher/widgets/card_widget.py
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel
from PySide6.QtGui import QIcon, QMouseEvent, QContextMenuEvent, QDrag, QPixmap, QPainter
from PySide6.QtCore import Qt, Signal, QSize, QMimeData, QPoint

class CardWidget(QWidget):
    doubleClicked = Signal(str)
    customContextMenuRequested = Signal(str, QContextMenuEvent)

    def __init__(self, program_data: dict, icon: QIcon, parent=None):
        super().__init__(parent)
        self.program_id = program_data.get('id')
        self.program_data = program_data
        self.setFixedSize(100, 100)
        self.setToolTip(program_data.get('path', ''))
        self.drag_start_position = None

        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 10, 5, 10)
        layout.setSpacing(5)
        self.icon_label = QLabel()
        self.icon_label.setPixmap(icon.pixmap(QSize(48, 48)))
        self.icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.name_label = QLabel(program_data.get('name', ''))
        self.name_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.name_label.setWordWrap(True)
        layout.addWidget(self.icon_label)
        layout.addWidget(self.name_label)
        layout.addStretch()
        self._set_style()

    def _set_style(self):
        self.setAutoFillBackground(True)
        self.setStyleSheet("""
            CardWidget { background-color: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef; }
            CardWidget:hover { background-color: #e9ecef; border: 1px solid #dee2e6; }
        """)

    def mousePressEvent(self, event: QMouseEvent):
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_start_position = event.position().toPoint()
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event: QMouseEvent):
        if not (event.buttons() & Qt.MouseButton.LeftButton): return
        if not self.drag_start_position or (event.position().toPoint() - self.drag_start_position).manhattanLength() < 10: return

        # 【修复】恢复自己创建QDrag的逻辑
        drag = QDrag(self)
        mime_data = QMimeData()
        mime_data.setData("application/x-program-launcher-card", self.program_id.encode('utf-8'))
        drag.setMimeData(mime_data)

        drag_pixmap = QPixmap(self.size()); drag_pixmap.fill(Qt.GlobalColor.transparent)
        painter = QPainter(drag_pixmap)
        painter.setOpacity(0.7); painter.drawPixmap(0, 0, self.grab()); painter.end()
        drag.setPixmap(drag_pixmap)
        drag.setHotSpot(event.position().toPoint())
        
        drag.exec(Qt.DropAction.MoveAction)

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        self.doubleClicked.emit(self.program_id)
        super().mouseDoubleClickEvent(event)
        
    def contextMenuEvent(self, event: QContextMenuEvent):
        self.customContextMenuRequested.emit(self.program_id, event)
        super().contextMenuEvent(event)
```
### delete_group_dialog.py
```python
# desktop_center/src/features/program_launcher/widgets/delete_group_dialog.py
from PySide6.QtWidgets import (QDialog, QVBoxLayout, QLabel, QRadioButton,
                               QComboBox, QDialogButtonBox, QWidget, QHBoxLayout)

class DeleteGroupDialog(QDialog):
    """
    一个自定义对话框，用于处理删除非空分组时的用户选择。
    """
    def __init__(self, group_name: str, other_groups: list, parent=None):
        super().__init__(parent)
        self.setWindowTitle("删除分组")
        self.setMinimumWidth(350)

        self.other_groups = other_groups
        self.result = (None, None)

        layout = QVBoxLayout(self)
        
        main_label = QLabel(f"分组 '{group_name}' 不为空。请选择如何处理其中的程序：")
        layout.addWidget(main_label)

        # 选项1: 移动到其他分组
        self.move_radio = QRadioButton("将所有程序移动到另一个分组:")
        layout.addWidget(self.move_radio)
        
        move_widget = QWidget()
        move_layout = QHBoxLayout(move_widget)
        move_layout.setContentsMargins(20, 0, 0, 0)
        self.group_combo = QComboBox()
        for group in self.other_groups:
            self.group_combo.addItem(group['name'], group['id'])
        move_layout.addWidget(self.group_combo)
        layout.addWidget(move_widget)
        
        # 选项2: 删除所有程序
        self.delete_all_radio = QRadioButton("删除此分组及其中的所有程序")
        layout.addWidget(self.delete_all_radio)

        # 根据是否有其他分组来设置默认状态
        if self.other_groups:
            self.move_radio.setChecked(True)
        else:
            self.move_radio.setText("将所有程序移动到一个新的'默认分组'")
            self.move_radio.setChecked(True)
            self.group_combo.setVisible(False)
        
        self.move_radio.toggled.connect(self.group_combo.setEnabled)

        # 按钮
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def accept(self):
        """当用户点击OK时，保存结果。"""
        if self.move_radio.isChecked():
            target_group_id = self.group_combo.currentData() if self.other_groups else None
            self.result = ('move', target_group_id)
        elif self.delete_all_radio.isChecked():
            self.result = ('delete_all', None)
        super().accept()

    def get_result(self) -> tuple:
        """获取用户的选择结果。"""
        return self.result
```
### group_dialog.py
```python
# desktop_center/src/features/program_launcher/widgets/group_dialog.py
from PySide6.QtWidgets import QDialog, QVBoxLayout, QLineEdit, QDialogButtonBox, QLabel

class GroupDialog(QDialog):
    """
    一个简单的对话框，用于获取用户输入的分组名称。
    """
    def __init__(self, parent=None, current_name=""):
        super().__init__(parent)
        self.setWindowTitle("分组信息")
        
        layout = QVBoxLayout(self)
        
        self.label = QLabel("分组名称:")
        self.line_edit = QLineEdit()
        if current_name:
            self.line_edit.setText(current_name)
            self.setWindowTitle("重命名分组")

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)

        layout.addWidget(self.label)
        layout.addWidget(self.line_edit)
        layout.addWidget(self.button_box)
        
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.line_edit.returnPressed.connect(self.accept)

    def get_group_name(self) -> str:
        """获取用户输入的文本。"""
        return self.line_edit.text().strip()
```
### group_header_widget.py
```python
# desktop_center/src/features/program_launcher/widgets/group_header_widget.py
from PySide6.QtWidgets import QWidget, QHBoxLayout, QLabel
from PySide6.QtGui import QMouseEvent, QContextMenuEvent, QDrag
from PySide6.QtCore import Qt, Signal, QMimeData

class GroupHeaderWidget(QWidget):
    customContextMenuRequested = Signal(str, QContextMenuEvent)

    def __init__(self, group_data: dict, parent=None):
        super().__init__(parent)
        self.group_id = group_data.get('id')
        self.drag_start_position = None
        
        self.setCursor(Qt.CursorShape.OpenHandCursor)
        layout = QHBoxLayout(self); layout.setContentsMargins(5, 0, 5, 0)
        self.title_label = QLabel(f"<b>{group_data.get('name', '')}</b>")
        self.title_label.setStyleSheet("padding: 15px 0 8px 0; font-size: 14px; border-bottom: 1px solid #e0e0e0;")
        layout.addWidget(self.title_label)
        
    def mousePressEvent(self, event: QMouseEvent):
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_start_position = event.position().toPoint()
            self.setCursor(Qt.CursorShape.ClosedHandCursor)
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event: QMouseEvent):
        self.setCursor(Qt.CursorShape.OpenHandCursor)
        super().mouseReleaseEvent(event)
        
    def mouseMoveEvent(self, event: QMouseEvent):
        if not (event.buttons() & Qt.MouseButton.LeftButton): return
        if not self.drag_start_position or (event.position().toPoint() - self.drag_start_position).manhattanLength() < 10: return

        # 【修复】恢复自己创建QDrag的逻辑
        drag = QDrag(self)
        mime_data = QMimeData()
        mime_data.setData("application/x-program-launcher-group", self.group_id.encode('utf-8'))
        drag.setMimeData(mime_data)

        pixmap = self.grab()
        drag.setPixmap(pixmap)
        drag.setHotSpot(event.position().toPoint())
        drag.exec(Qt.DropAction.MoveAction)

    def contextMenuEvent(self, event: QContextMenuEvent):
        self.customContextMenuRequested.emit(self.group_id, event)
        super().contextMenuEvent(event)
```



## 目前需要做的
审查下当前program_launcher的代码，看看这个插件现在采用的技术方案是否争取，代码是否有需要优化的，凝练的