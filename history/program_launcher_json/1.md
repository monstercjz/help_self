## 标题：高级工程师任务执行规则
### 适用范围：所有任务
### 规则说明：
你是一位经验丰富的高级软件工程师，专注于编写高质量、生产可用的代码。擅长在不引入副作用的前提下，完成精准的函数级变更、模块集成与缺陷修复。
在执行任何任务时，必须严格遵守以下流程规范，不得跳过或简化任一步骤。：
- 1.先明确任务范围
在编写任何代码之前，必须先明确任务的处理方式。确认你对任务目标的理解无误。
撰写一份清晰的计划，说明将会涉及哪些函数、模块或组件，并解释原因。未完成以上步骤并合理推理之前，禁止开始编码。
- 2.找到精确的代码插入点
明确指出变更应落地到哪个文件的哪一行。严禁对无关文件进行大范围修改。
如需涉及多个文件，必须逐一说明每个文件的必要性。除非任务明确要求，否则不得新增抽象、重构已有结构。
- 3.仅做最小且封闭的更改
只编写为满足任务而必须实现的代码。
严禁任何“顺便”性质的修改或推测性变动。
所有逻辑必须做到隔离，确保不影响已有流程。
- 4.全面复查每一项变更
检查代码是否正确、符合任务范围，避免副作用。
保证代码风格与现有代码保持一致，防止引入回归问题。明确确认此改动是否会影响到下游流程。
- 5.清晰交付成果
做好代码变更的版本日志，做好新增及变化代码相应的注释，严禁随意修改删除已有注释。
总结变更内容及其原因。
列出所有被修改的文件及每个文件的具体改动。如果有任何假设或风险，请明确标注以供评审。
最终提交的代码应该是涉及到代码变更的整个代码文件，禁止提供有折叠的不完整代码块。
### 提醒：
你不是副驾驶、助手或头脑风暴的参与者。你是负责高杠杆、生产安全级变更的高级工程师。请勿即兴设计或偏离规范。

## 项目新架构
desktop_center/
.
├── .gitignore
├── app.py
├── config.ini
├── icon.ico
├── icon.png
├── README.md
├── requirements.txt
├── src/
│   ├── __init__.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── context.py
│   │   ├── plugin_interface.py
│   │   └── plugin_manager.py
│   ├── features/
│   │   ├── __init__.py
│   │   ├── alert_center/
│   │   │   ├── __init__.py
│   │   │   ├── database_extensions.py
│   │   │   ├── plugin.py
│   │   │   ├── README.md
│   │   │   ├── controllers/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── alerts_page_controller.py
│   │   │   │   ├── history_controller.py
│   │   │   │   ├── statistics_dialog_controller.py
│   │   │   │   └── statistics/
│   │   │   │       ├── __init__.py
│   │   │   │       ├── custom_analysis_controller.py
│   │   │   │       ├── hourly_stats_controller.py
│   │   │   │       ├── ip_activity_controller.py
│   │   │   │       ├── multidim_analysis_controller.py
│   │   │   │       └── type_stats_controller.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── custom_analysis_model.py
│   │   │   │   ├── history_model.py
│   │   │   │   └── statistics_model.py
│   │   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   └── alert_receiver.py
│   │   │   ├── views/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── alerts_page_view.py
│   │   │   │   ├── history_dialog_view.py
│   │   │   │   ├── statistics_dialog_view.py
│   │   │   │   └── statistics/
│   │   │   │       ├── __init__.py
│   │   │   │       ├── custom_analysis_view.py
│   │   │   │       ├── hourly_stats_view.py
│   │   │   │       ├── ip_activity_view.py
│   │   │   │       ├── multidim_analysis_view.py
│   │   │   │       └── type_stats_view.py
│   │   │   └── widgets/
│   │   │       ├── __init__.py
│   │   │       ├── date_filter_widget.py
│   │   │       └── ip_filter_widget.py
│   │   └── window_arranger/
│   │       ├── __init__.py
│   │       ├── plugin.py
│   │       ├── README.md
│   │       ├── controllers/
│   │       │   ├── __init__.py
│   │       │   ├── arranger_controller.py
│   │       │   └── sorting_strategy_manager.py
│   │       ├── models/
│   │       │   ├── __init__.py
│   │       │   └── window_info.py
│   │       ├── services/
│   │       │   ├── __init__.py
│   │       │   └── monitor_service.py
│   │       ├── sorting_strategies/
│   │       │   ├── __init__.py
│   │       │   ├── default_sort_strategy.py
│   │       │   ├── numeric_sort_strategy.py
│   │       │   └── sort_strategy_interface.py
│   │       └── views/
│   │           ├── __init__.py
│   │           ├── arranger_page_view.py
│   │           └── settings_dialog_view.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── config_service.py
│   │   ├── database_service.py
│   │   ├── notification_service.py
│   │   └── webhook_service.py
│   ├── ui/
│   │   ├── __init__.py
│   │   ├── action_manager.py
│   │   ├── main_window.py
│   │   └── settings_page.py
│   └── utils/
│       ├── __init__.py
│       ├── exception_handler.py
│       └── tray_manager.py
└── tests/
    └── test_config_service.py

        
- 终极解耦: “告警中心”和未来的“进程排序器”完全不知道对方的存在。它们只与平台核心的接口和上下文交互。
- 可扩展性极强:
    添加新功能: 只需在 src/features/ 目录下创建一个新文件夹，实现 IFeaturePlugin 接口，应用重启后就会自动加载，无需修改任何核心代码。
    扩展子功能: 在插件内部，你依然可以沿用MVC等模式来组织代码，保持子功能的清晰。
- 职责清晰:
src/core: 定义游戏规则。
src/features: 玩家。
app.py: 游戏裁判和场地。
src/services: 公共设施。
- 利于团队协作: 不同的开发者可以并行开发不同的插件，只要都遵守 IFeaturePlugin 接口，就不会互相干扰。
- 按需加载: 平台可以被配置为只加载某些插件，实现不同版本（基础版/专业版）的软件分发。



## 说明
基础架构的代码我就不贴出来了，基本没有改动的必要了，我们着眼于插件的具体代码，现在要完善program-launcher这个新的插件
## program-launcher
### plugin.py
```python
# desktop_center/src/features/program_launcher/plugin.py
import logging
from src.core.plugin_interface import IFeaturePlugin
from src.core.context import ApplicationContext

# 导入插件内部的MVC组件
from .controllers.launcher_controller import LauncherController
from .models.launcher_model import LauncherModel
from .views.launcher_page_view import LauncherPageView

class ProgramLauncherPlugin(IFeaturePlugin):
    """
    程序启动器插件，提供管理和快速启动应用程序的功能。
    """
    
    def name(self) -> str:
        """返回插件的唯一内部名称。"""
        return "program_launcher"

    def display_name(self) -> str:
        """返回插件在UI上显示的名称。"""
        return "程序启动器"
        
    def load_priority(self) -> int:
        """返回插件的加载优先级。"""
        return 100 # 普通独立功能插件

    def initialize(self, context: ApplicationContext):
        """
        初始化插件，创建并连接MVC组件。
        """
        super().initialize(context)
        logging.info(f"[{self.name()}]-> 插件初始化开始...")

        # 1. 创建模型，并将ConfigService注入，以实现路径配置化
        # 【修改】将 context.config_service 传递给模型
        self.model = LauncherModel(config_service=context.config_service)

        # 2. 创建视图
        self.view = LauncherPageView()

        # 3. 创建控制器，将模型和视图注入
        self.controller = LauncherController(self.model, self.view, context)

        # 4. 将视图（主页面）设置为插件的UI页面
        self.page_widget = self.view
        
        logging.info(f"[{self.name()}]-> 插件初始化完成。")

    def shutdown(self):
        """
        在应用程序关闭时，确保数据被保存。
        """
        logging.info(f"[{self.name()}]-> 插件关闭，正在保存数据...")
        if hasattr(self, 'model'):
            self.model.save_data()
        super().shutdown()
        logging.info(f"[{self.name()}]-> 插件已关闭。")
```
### launcher_controller.py
```python
# desktop_center/src/features/program_launcher/controllers/launcher_controller.py
import logging
import os
import subprocess
import sys
from PySide6.QtWidgets import QFileDialog, QMessageBox, QDialog
from PySide6.QtCore import QObject, Slot

from ..models.launcher_model import LauncherModel
from ..views.launcher_page_view import LauncherPageView
from ..widgets.group_dialog import GroupDialog
from ..widgets.delete_group_dialog import DeleteGroupDialog
from ..widgets.add_program_dialog import AddProgramDialog
from src.core.context import ApplicationContext

class LauncherController(QObject):
    def __init__(self, model: LauncherModel, view: LauncherPageView, context: ApplicationContext, parent=None):
        super().__init__(parent)
        self.model = model
        self.view = view
        self.context = context
        
        # 读取树状视图的配置，遵循项目通用模式
        self.tree_view_icon_size = int(self.context.config_service.get_value(
            "ProgramLauncher", "treeview_iconsize", fallback="20"
        ))
        self.tree_view_font_size = int(self.context.config_service.get_value(
            "ProgramLauncher", "treeview_fontsize", fallback="10"
        ))

        self._connect_signals()
        self.refresh_view()

    def _connect_signals(self):
        self.view.add_group_requested.connect(self.add_group)
        self.view.add_program_requested.connect(self.handle_add_program_request)
        self.view.item_double_clicked.connect(self.launch_program)
        self.view.edit_item_requested.connect(self.edit_item)
        self.view.delete_item_requested.connect(self.delete_item)
        self.view.search_text_changed.connect(self.filter_view)
        self.view.change_data_path_requested.connect(self.change_data_path)
        self.view.program_dropped.connect(self.handle_program_drop)
        # 同时监听来自两个视图的分组排序信号
        self.view.icon_view.group_order_changed.connect(self.model.reorder_groups)
        self.view.tree_view.group_order_changed.connect(self.model.reorder_groups)
        self.model.data_changed.connect(self.refresh_view)

    # ... 其他方法基本保持不变 ...
    def refresh_view(self):
        logging.info("[CONTROLLER] Refreshing view from model data.")
        data = self.model.get_all_data()
        # 将配置传递给视图
        data['tree_view_config'] = {
            'icon_size': self.tree_view_icon_size,
            'font_size': self.tree_view_font_size
        }
        self.view.rebuild_ui(data)
    @Slot(str, str, int)
    def handle_program_drop(self, program_id: str, target_group_id: str, target_index: int):
        logging.info(f"[CONTROLLER] Handling program drop: prog_id={program_id}, group_id={target_group_id}, index={target_index}")
        self.model.move_program(program_id, target_group_id, target_index)
    @Slot()
    def add_group(self):
        dialog = GroupDialog(self.view)
        if dialog.exec():
            group_name = dialog.get_group_name()
            if group_name:
                self.model.add_group(group_name)
                self.context.notification_service.show("成功", f"分组 '{group_name}' 已创建。")
    @Slot(str)
    def handle_add_program_request(self, group_id: str = None):
        all_groups = self.model.get_all_data().get('groups', [])
        if not all_groups:
            reply = QMessageBox.information(self.view, "需要分组", "目前没有程序分组，请先创建一个。",
                                            QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Ok: self.add_group()
            return
        dialog = AddProgramDialog(all_groups, default_group_id=group_id, parent=self.view)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            details = dialog.get_program_details()
            if details:
                gid, name, path = details
                self.model.add_program(gid, name, path)
                self.context.notification_service.show("成功", f"程序 '{name}' 已添加。")
    @Slot(str)
    def launch_program(self, program_id: str):
        program = self.model.get_program_by_id(program_id)
        if program and os.path.exists(program['path']):
            try:
                # 使用 startfile 在 Windows 上更健壮，对于非 .exe 文件（如快捷方式）也能更好地工作
                if sys.platform == "win32":
                    os.startfile(program['path'])
                else:
                    subprocess.Popen([program['path']])
                
                self.context.notification_service.show(
                    title="程序已启动", message=f"{program['name']} 正在启动。"
                )
            except Exception as e:
                logging.error(f"Failed to launch program {program['name']} ({program['path']}): {e}")
                QMessageBox.critical(self.view, "启动失败", f"无法启动程序：\n{program['path']}\n\n错误: {e}")
        else:
            QMessageBox.warning(self.view, "启动失败", "程序路径不存在或已被移动，请编辑或删除此条目。")
    @Slot(str, str)
    def edit_item(self, item_id: str, item_type: str):
        if item_type == 'group':
            group = self.model.get_group_by_id(item_id)
            if not group: return
            dialog = GroupDialog(self.view, current_name=group['name'])
            if dialog.exec():
                new_name = dialog.get_group_name()
                if new_name and new_name != group['name']:
                    self.model.edit_group(item_id, new_name)
                    self.context.notification_service.show("成功", f"分组已重命名为 '{new_name}'。")
        elif item_type == 'program':
            program_to_edit = self.model.get_program_by_id(item_id)
            if not program_to_edit: return
            all_groups = self.model.get_all_data().get('groups', [])
            dialog = AddProgramDialog(all_groups, program_to_edit=program_to_edit, parent=self.view)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                new_group_id, new_name, new_path = dialog.get_program_details()
                self.model.edit_program(item_id, new_group_id, new_name, new_path)
                self.context.notification_service.show("成功", f"程序 '{new_name}' 已更新。")
    @Slot(str, str)
    def delete_item(self, item_id: str, item_type: str):
        if item_type == 'group': self._handle_delete_group(item_id)
        elif item_type == 'program':
            program = self.model.get_program_by_id(item_id)
            if not program: return
            reply = QMessageBox.question(self.view, "确认删除", f"您确定要删除程序 '{program['name']}' 吗？",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes:
                self.model.delete_program(item_id)
                self.context.notification_service.show("成功", f"程序 '{program['name']}' 已删除。")
    def _handle_delete_group(self, group_id: str):
        group = self.model.get_group_by_id(group_id)
        if not group: return
        other_groups = self.model.get_other_groups(group_id)
        programs_in_group = self.model.get_programs_in_group(group_id)
        if not programs_in_group:
            reply = QMessageBox.question(self.view, "确认删除", f"您确定要删除空分组 '{group['name']}' 吗？",
                                         QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                         QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes:
                self.model.delete_group(group_id)
                self.context.notification_service.show("成功", f"分组 '{group['name']}' 已删除。")
            return
        dialog = DeleteGroupDialog(group['name'], other_groups, self.view)
        if dialog.exec():
            choice, target_group_id = dialog.get_result()
            if choice == 'move':
                if not target_group_id and not other_groups:
                    target_group_id = self.model.add_group("默认分组")
                self.model.move_programs_to_group(group_id, target_group_id)
                self.model.delete_group(group_id)
                self.context.notification_service.show("成功", f"分组 '{group['name']}' 已删除，其下所有程序已移动。")
            elif choice == 'delete_all':
                self.model.delete_group(group_id, delete_programs=True)
                self.context.notification_service.show("成功", f"分组 '{group['name']}' 及其下所有程序已删除。")
    @Slot(str)
    def filter_view(self, text: str):
        """
        根据文本过滤视图。
        如果文本为空，则显示所有数据；否则，显示过滤后的数据。
        """
        if not text:
            self.refresh_view()
        else:
            filtered_data = self.model.filter_data(text)
            self.view.rebuild_ui(filtered_data)
    @Slot()
    def change_data_path(self):
        current_path = self.model.data_file
        new_path, _ = QFileDialog.getOpenFileName(
            self.view, "选择或指定程序启动器数据文件",
            os.path.dirname(current_path), "JSON 文件 (*.json);;所有文件 (*)"
        )
        if new_path and new_path != current_path:
            try:
                self.model.set_data_path(new_path)
                QMessageBox.information(
                    self.view, "成功", f"数据源已成功切换到:\n{new_path}\n\n界面已刷新。"
                )
            except Exception as e:
                QMessageBox.critical(
                    self.view, "操作失败", f"无法切换数据源到: {new_path}\n\n设置未更改。"
                )
```
### launcher_model.py
```python
# desktop_center/src/features/program_launcher/models/launcher_model.py
import json
import logging
import os
import sys
import shutil
import uuid
from PySide6.QtCore import QObject, Signal
from PySide6.QtWidgets import QMessageBox

from src.services.config_service import ConfigService

CONFIG_SECTION = "ProgramLauncher"

class LauncherModel(QObject):
    data_changed = Signal()

    def __init__(self, config_service: ConfigService, parent=None):
        super().__init__(parent)
        self.config_service = config_service
        default_path = "launcher_data.json"
        self.data_file = self.config_service.get_value(CONFIG_SECTION, "data_file_path", default_path)
        self.data = {"groups": [], "programs": {}}
        self.load_data()

    def load_data(self):
        try:
            if os.path.exists(self.data_file):
                with open(self.data_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    if not content:
                        self.data = {"groups": [], "programs": {}}
                        return
                    self.data = json.loads(content)
                    if "groups" not in self.data: self.data["groups"] = []
                    if "programs" not in self.data: self.data["programs"] = {}
                logging.info(f"已从 {self.data_file} 加载启动器数据。")
            else:
                logging.warning(f"启动器数据文件 {self.data_file} 不存在，将视为空配置。")
                self.data = {"groups": [], "programs": {}}
        except (json.JSONDecodeError, IOError) as e:
            logging.error(f"加载启动器数据文件 {self.data_file} 失败: {e}")
            
            # 备份损坏的文件
            backup_path = self.data_file + ".bak"
            try:
                shutil.copy(self.data_file, backup_path)
                backup_msg = f"损坏的文件已为您备份到:\n{backup_path}"
            except Exception as backup_e:
                backup_msg = f"尝试备份文件失败: {backup_e}"

            # 弹出错误对话框
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Icon.Critical)
            msg_box.setWindowTitle("数据文件损坏")
            msg_box.setText(f"无法加载数据文件，它可能已损坏。\n{backup_msg}")
            msg_box.setInformativeText("您可以选择以一个全新的空配置启动，或退出程序以手动检查文件。")
            
            reset_btn = msg_box.addButton("以空配置启动", QMessageBox.ButtonRole.AcceptRole)
            exit_btn = msg_box.addButton("退出", QMessageBox.ButtonRole.RejectRole)
            msg_box.setDefaultButton(reset_btn)
            
            msg_box.exec()

            if msg_box.clickedButton() == exit_btn:
                sys.exit(1) # 退出程序
            
            # 用户选择重置
            self.data = {"groups": [], "programs": {}}

    def save_data(self):
        try:
            logging.info(f"[MODEL] Saving data to {self.data_file}...")
            dir_name = os.path.dirname(self.data_file)
            if dir_name: os.makedirs(dir_name, exist_ok=True)
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, indent=4, ensure_ascii=False)
            logging.info(f"启动器数据已成功保存到 {self.data_file}。")
        except IOError as e:
            logging.error(f"保存启动器数据到 {self.data_file} 失败: {e}")
            
    def set_data_path(self, new_path: str):
        if new_path == self.data_file: return
        self.config_service.set_option(CONFIG_SECTION, "data_file_path", new_path)
        # 不应在此处保存整个配置文件，这会导致其他未被set的配置项丢失。
        # 保存操作应由更高层级的应用逻辑（如退出或全局设置保存）触发。
        self.config_service.save_config()
        self.data_file = new_path
        try:
            self.load_data()
            self.data_changed.emit()
        except Exception:
            raise

    def update_full_structure(self, new_structure: dict):
        logging.info("[MODEL] Updating full data structure based on UI.")
        self.data = new_structure
        self.save_data()
        self.data_changed.emit()

    def get_all_data(self):
        return json.loads(json.dumps(self.data))

    def add_group(self, name: str) -> str:
        new_group = {"id": str(uuid.uuid4()), "name": name}
        self.data["groups"].append(new_group)
        self.save_data()
        self.data_changed.emit()
        return new_group["id"]

    def edit_group(self, group_id: str, new_name: str):
        for group in self.data["groups"]:
            if group["id"] == group_id:
                group["name"] = new_name
                self.save_data()
                self.data_changed.emit()
                return

    def reorder_groups(self, group_ids: list[str]):
        """
        根据给定的ID列表，对分组进行重新排序。

        Args:
            group_ids: 包含分组ID的新顺序列表。
        """
        if not group_ids: return
        
        # 创建一个从 group_id 到 group 对象的映射，以便快速查找
        group_map = {g['id']: g for g in self.data['groups']}
        
        # 根据传入的 group_ids 列表，构建一个新的、有序的分组列表
        # 这里会过滤掉任何可能不存在于 group_map 中的ID，以增加健壮性
        new_groups_order = [group_map[gid] for gid in group_ids if gid in group_map]
        
        # 安全检查：如果新旧列表的长度不匹配，说明可能丢失了数据或传入了无效ID。
        # 在这种情况下，我们选择不执行更新，以避免数据损坏。
        if len(new_groups_order) == len(self.data['groups']):
            self.data['groups'] = new_groups_order
            self.save_data()
            self.data_changed.emit()
            logging.info(f"Model: Group order has been updated to: {group_ids}")
        else:
            logging.warning(f"Group reorder failed due to ID mismatch. Expected {len(self.data['groups'])}, got {len(new_groups_order)}")


    def delete_group(self, group_id: str, delete_programs: bool = False):
        self.data["groups"] = [g for g in self.data["groups"] if g["id"] != group_id]
        if delete_programs:
            self.data["programs"] = {pid: p for pid, p in self.data["programs"].items() if p["group_id"] != group_id}
        self.save_data()
        self.data_changed.emit()

    def add_program(self, group_id: str, name: str, path: str):
        program_id = str(uuid.uuid4())
        self.data["programs"][program_id] = {
            "id": program_id, "group_id": group_id, "name": name, "path": path,
            "order": len(self.get_programs_in_group(group_id))
        }
        self.save_data()
        self.data_changed.emit()

    def edit_program(self, program_id: str, new_group_id: str, new_name: str, new_path: str):
        if program_id in self.data['programs']:
            program = self.data['programs'][program_id]
            # 如果分组发生了变化，需要调整两个分组的order
            if program['group_id'] != new_group_id:
                self.move_program(program_id, new_group_id, 9999) # 移动到新分组末尾
            program['group_id'] = new_group_id
            program['name'] = new_name
            program['path'] = new_path
            self.save_data()
            self.data_changed.emit()
            logging.info(f"程序已编辑: ID={program_id}, Name={new_name}")

    def delete_program(self, program_id: str):
        program_to_delete = self.data['programs'].pop(program_id, None)
        if not program_to_delete: return
        
        # 重新计算被删除程序所在分组的 order
        group_id = program_to_delete['group_id']
        remaining_progs = self.get_programs_in_group(group_id)
        for i, p in enumerate(remaining_progs):
            p['order'] = i
        
        self.save_data()
        self.data_changed.emit()
            
    def get_program_by_id(self, program_id: str) -> dict | None:
        return self.data["programs"].get(program_id)
        
    def get_group_by_id(self, group_id: str) -> dict | None:
        for group in self.data["groups"]:
            if group["id"] == group_id: return group
        return None

    def get_programs_in_group(self, group_id: str) -> list:
        programs = [p for p in self.data["programs"].values() if p.get('group_id') == group_id]
        programs.sort(key=lambda p: p.get("order", 0))
        return programs
        
    def get_other_groups(self, group_id_to_exclude: str) -> list:
        return [g for g in self.data["groups"] if g["id"] != group_id_to_exclude]

    def move_programs_to_group(self, old_group_id: str, new_group_id: str):
        for program in self.data["programs"].values():
            if program["group_id"] == old_group_id:
                program["group_id"] = new_group_id

    def filter_data(self, text: str) -> dict:
        """
        根据搜索文本过滤数据。

        Args:
            text: 用于搜索的文本。

        Returns:
            一个只包含匹配项的新的数据字典。
        """
        if not text:
            return self.get_all_data()

        text = text.lower()
        
        filtered_programs = {}
        visible_group_ids = set()

        # 过滤程序
        for prog_id, prog_data in self.data["programs"].items():
            if text in prog_data.get('name', '').lower():
                filtered_programs[prog_id] = prog_data
                visible_group_ids.add(prog_data.get('group_id'))

        # 过滤分组（如果分组名匹配，或其下有匹配的程序）
        filtered_groups = []
        for group_data in self.data["groups"]:
            group_id = group_data.get('id')
            if text in group_data.get('name', '').lower() or group_id in visible_group_ids:
                filtered_groups.append(group_data)

        return {"groups": filtered_groups, "programs": filtered_programs}

    def move_program(self, program_id: str, target_group_id: str, target_index: int):
        """
        移动一个程序到新的位置，这可能是在同一个分组内，也可能是在不同分组之间。
        此方法通过直接修改 self.data 并重新计算受影响分组的 order 来保证数据一致性。
        """
        program_to_move = self.data['programs'].get(program_id)
        if not program_to_move:
            logging.error(f"move_program: Program with id {program_id} not found.")
            return

        source_group_id = program_to_move['group_id']

        # 步骤 1: 立即在核心数据中更新被移动程序的 group_id
        program_to_move['group_id'] = target_group_id

        # 步骤 2: 重新生成并更新目标分组的顺序
        target_progs = self.get_programs_in_group(target_group_id)
        
        # 为了处理组内拖拽，我们需要从列表中移除旧的项
        # 使用列表推导式来安全地移除
        target_progs = [p for p in target_progs if p['id'] != program_id]
        
        # 确保索引有效
        if target_index > len(target_progs):
            target_index = len(target_progs)
        target_progs.insert(target_index, program_to_move)
        
        # 遍历这个顺序正确的列表，更新核心数据中的 order
        for i, prog in enumerate(target_progs):
            self.data['programs'][prog['id']]['order'] = i

        # 步骤 3: 如果是跨组移动，重新生成并更新源分组的顺序
        if source_group_id != target_group_id:
            source_progs = self.get_programs_in_group(source_group_id)
            for i, prog in enumerate(source_progs):
                self.data['programs'][prog['id']]['order'] = i
        
        logging.info(f"Model: Program {program_id} moved to group {target_group_id} at index {target_index}. Triggering save and refresh.")
        self.save_data()
        self.data_changed.emit()

```
### launcher_page_view.py
```python
# desktop_center/src/features/program_launcher/views/launcher_page_view.py
import logging
import os
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QPushButton, QHBoxLayout,
                               QLineEdit, QSpacerItem, QSizePolicy, QStackedWidget, QButtonGroup)
from PySide6.QtCore import Signal, QDir
from PySide6.QtGui import QIcon

from .modes.base_view import BaseViewMode
from .modes.tree_view import TreeViewMode
from .modes.icon_view import IconViewMode
from ..widgets.empty_state_widget import EmptyStateWidget
from ..widgets.no_results_widget import NoResultsWidget

class LauncherPageView(QWidget):
    # ... 信号定义保持不变 ...
    add_group_requested = Signal()
    add_program_requested = Signal(str)
    item_double_clicked = Signal(str)
    edit_item_requested = Signal(str, str)
    delete_item_requested = Signal(str, str)
    search_text_changed = Signal(str)
    change_data_path_requested = Signal()
    program_dropped = Signal(str, str, int)
    group_order_changed = Signal(list)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("LauncherPageView") # 为顶层窗口设置对象名称
        self.data_cache = {}
        self._init_ui()
        self._load_stylesheet()
        self.tree_view.update_view({})

    def _init_ui(self):
        # ... UI创建部分保持不变 ...
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        toolbar_layout = QHBoxLayout()
        self.add_group_btn = QPushButton(QIcon.fromTheme("list-add"), " 新建分组")
        self.add_program_btn = QPushButton(QIcon.fromTheme("document-new"), " 添加程序")
        self.search_bar = QLineEdit()
        self.search_bar.setPlaceholderText("搜索程序...")
        self.clear_action = self.search_bar.addAction(QIcon.fromTheme("edit-clear"), QLineEdit.ActionPosition.TrailingPosition)
        self.clear_action.setVisible(False)
        self.settings_btn = QPushButton()
        self.settings_btn.setIcon(QIcon.fromTheme("emblem-system"))
        self.settings_btn.setToolTip("设置数据文件路径")
        self.view_mode_group = QButtonGroup(self)
        self.tree_view_btn = QPushButton(QIcon.fromTheme("view-list-tree"), "")
        self.tree_view_btn.setToolTip("树状视图")
        self.tree_view_btn.setCheckable(True)
        self.icon_view_btn = QPushButton(QIcon.fromTheme("view-grid"), "")
        self.icon_view_btn.setToolTip("图标视图")
        self.icon_view_btn.setCheckable(True)
        self.view_mode_group.addButton(self.tree_view_btn, 0)
        self.view_mode_group.addButton(self.icon_view_btn, 1)
        self.tree_view_btn.setChecked(True)
        toolbar_layout.addWidget(self.add_group_btn)
        toolbar_layout.addWidget(self.add_program_btn)
        toolbar_layout.addSpacerItem(QSpacerItem(20, 20, QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum))
        toolbar_layout.addWidget(self.search_bar)
        toolbar_layout.addWidget(self.tree_view_btn)
        toolbar_layout.addWidget(self.icon_view_btn)
        toolbar_layout.addWidget(self.settings_btn)
        layout.addLayout(toolbar_layout)
        self.stacked_widget = QStackedWidget()
        self.tree_view = TreeViewMode()
        self.icon_view = IconViewMode()
        self.empty_state_view = EmptyStateWidget()
        self.no_results_view = NoResultsWidget()
        self.stacked_widget.addWidget(self.tree_view)
        self.stacked_widget.addWidget(self.icon_view)
        self.stacked_widget.addWidget(self.empty_state_view)
        self.stacked_widget.addWidget(self.no_results_view)
        layout.addWidget(self.stacked_widget)
        
        # 连接信号
        self.add_group_btn.clicked.connect(self.add_group_requested)
        self.add_program_btn.clicked.connect(lambda: self.add_program_requested.emit(None))
        self.settings_btn.clicked.connect(self.change_data_path_requested)
        self.search_bar.textChanged.connect(self.search_text_changed)
        self.clear_action.triggered.connect(self.search_bar.clear)
        self.search_bar.textChanged.connect(self._update_clear_button_visibility)
        self.view_mode_group.idClicked.connect(self.stacked_widget.setCurrentIndex)
        self.stacked_widget.currentChanged.connect(self.on_view_mode_changed)
        self.empty_state_view.add_group_requested.connect(self.add_group_requested)
        self._connect_view_signals(self.tree_view)
        self._connect_view_signals(self.icon_view)

    def _connect_view_signals(self, view: BaseViewMode):
        view.item_double_clicked.connect(self.item_double_clicked)
        view.edit_item_requested.connect(self.edit_item_requested)
        view.delete_item_requested.connect(self.delete_item_requested)
        view.program_dropped.connect(self.program_dropped)
        view.add_program_to_group_requested.connect(self.add_program_requested)
        view.group_order_changed.connect(self.group_order_changed)

    def rebuild_ui(self, data: dict):
        self.data_cache = data
        
        is_data_empty = not data.get("groups") and not data.get("programs")
        is_searching = bool(self.search_bar.text())

        # 根据数据是否为空以及是否在搜索，来决定显示哪个视图
        if is_data_empty and not is_searching:
            # 状态1: 真正的空状态
            self.stacked_widget.setCurrentWidget(self.empty_state_view)
            self.search_bar.setVisible(False)
            self.tree_view_btn.setVisible(False)
            self.icon_view_btn.setVisible(False)
        elif is_data_empty and is_searching:
            # 状态2: 搜索无结果
            self.stacked_widget.setCurrentWidget(self.no_results_view)
            self.search_bar.setVisible(True) # 保持搜索框可见
            self.tree_view_btn.setVisible(False)
            self.icon_view_btn.setVisible(False)
        else:
            # 状态3: 正常显示数据
            current_id = self.view_mode_group.checkedId()
            self.stacked_widget.setCurrentIndex(current_id)
            self.search_bar.setVisible(True)
            self.tree_view_btn.setVisible(True)
            self.icon_view_btn.setVisible(True)

        # 即使在显示占位符时，也更新后台视图的数据，以确保切换回来时内容是最新的
        self.tree_view.update_view(data)
        self.icon_view.update_view(data)

    def on_view_mode_changed(self, index: int):
        # 当视图模式改变时，我们不需要做任何特别的操作，
        # 因为两个视图的数据在 rebuild_ui 中总是同步的。
        # 搜索过滤也由控制器统一处理。
        pass

    def _update_clear_button_visibility(self, text: str):
        self.clear_action.setVisible(bool(text))

    def _load_stylesheet(self):
        """加载外部QSS样式表。"""
        # 使用相对路径定位样式文件
        current_dir = os.path.dirname(os.path.abspath(__file__))
        style_path = os.path.join(current_dir, '..', 'assets', 'style.qss')
        
        if os.path.exists(style_path):
            with open(style_path, 'r', encoding='utf-8') as f:
                style = f.read()
                self.setStyleSheet(style)
                logging.info(f"Stylesheet loaded from {style_path}")
        else:
            logging.warning(f"Stylesheet not found at {style_path}")

```
### base_view.py
```python
# desktop_center/src/features/program_launcher/views/modes/base_view.py
from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Signal

class BaseViewMode(QWidget):
    item_double_clicked = Signal(str)
    edit_item_requested = Signal(str, str)
    delete_item_requested = Signal(str, str)
    add_program_to_group_requested = Signal(str)
    items_moved = Signal() # 用于树状视图
    program_dropped = Signal(str, str, int) # 用于图标视图的程序卡片
    group_order_changed = Signal(list) # 【新增】用于图标视图的分组排序

    def __init__(self, parent=None):
        super().__init__(parent)

    def update_view(self, data: dict):
        raise NotImplementedError("Subclasses of BaseViewMode must implement the 'update_view' method.")
```
### flow_layout.py
```python
# desktop_center/src/features/program_launcher/views/modes/flow_layout.py
# Copyright (C) 2013 Riverbank Computing Limited.
# Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
# All rights reserved.
#
# This file is part of the examples of PyQt.
#
# $QT_BEGIN_LICENSE:BSD$
# You may use this file under the terms of the BSD license as follows:
#
# "Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#   * Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
#   * Neither the name of Nokia Corporation and its Subsidiary(-ies) nor
#     the names of its contributors may be used to endorse or promote
#     products derived from this software without specific prior written
#     permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, or TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
# $QT_END_LICENSE$

from PySide6.QtCore import QPoint, QRect, QSize, Qt
from PySide6.QtWidgets import QLayout, QSizePolicy, QSpacerItem

class FlowLayout(QLayout):
    def __init__(self, parent=None, margin=-1, h_spacing=-1, v_spacing=-1):
        super(FlowLayout, self).__init__(parent)
        if margin != -1:
            self.setContentsMargins(margin, margin, margin, margin)
        self.h_spacing = h_spacing
        self.v_spacing = v_spacing
        self.item_list = []

    def __del__(self):
        item = self.takeAt(0)
        while item:
            item = self.takeAt(0)

    def addItem(self, item):
        self.item_list.append(item)

    def count(self):
        return len(self.item_list)

    def itemAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list[index]
        return None

    def takeAt(self, index):
        if 0 <= index < len(self.item_list):
            return self.item_list.pop(index)
        return None

    def expandingDirections(self):
        return Qt.Orientation(0)

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        height = self._do_layout(QRect(0, 0, width, 0), True)
        return height

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self._do_layout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QSize()
        for item in self.item_list:
            size = size.expandedTo(item.minimumSize())
        margin, _, _, _ = self.getContentsMargins()
        size += QSize(2 * margin, 2 * margin)
        return size

    def _do_layout(self, rect, test_only):
        x = rect.x()
        y = rect.y()
        line_height = 0
        spacing = self.spacing()
        if spacing == -1:
            spacing = self.style().layoutSpacing(QSizePolicy.ControlType.PushButton, QSizePolicy.ControlType.PushButton, Qt.Orientation.Horizontal)
        
        h_spacing = self.h_spacing if self.h_spacing >= 0 else spacing
        v_spacing = self.v_spacing if self.v_spacing >= 0 else spacing

        for item in self.item_list:
            next_x = x + item.sizeHint().width() + h_spacing
            if next_x - h_spacing > rect.right() and line_height > 0:
                x = rect.x()
                y = y + line_height + v_spacing
                next_x = x + item.sizeHint().width() + h_spacing
                line_height = 0
            if not test_only:
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))
            x = next_x
            line_height = max(line_height, item.sizeHint().height())
        return y + line_height - rect.y()
```
### icon_view.py
```python
# desktop_center/src/features/program_launcher/views/modes/icon_view.py
import logging
import math
from PySide6.QtWidgets import (QVBoxLayout, QLabel, QWidget, QScrollArea, QFrame, QGridLayout)
from PySide6.QtGui import QDragEnterEvent, QDropEvent, QDragMoveEvent
from PySide6.QtCore import Qt, QPoint, QRect

from .base_view import BaseViewMode
from ...widgets.card_widget import CardWidget
from ...services.icon_service import icon_service
from ...widgets.menu_factory import MenuFactory
from ...widgets.group_container_widget import GroupContainerWidget

class IconViewMode(BaseViewMode):
    COLUMNS = 3 # 定义网格列数

    def __init__(self, parent=None):
        super().__init__(parent)
        self.group_containers = {}
        
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QScrollArea.Shape.NoFrame)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        self.content_widget = QWidget()
        self.content_widget.setAcceptDrops(True)
        
        self.content_layout = QGridLayout(self.content_widget)
        self.content_layout.setSpacing(15)
        self.content_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        
        scroll_area.setWidget(self.content_widget)
        main_layout.addWidget(scroll_area)

        self.drop_indicator = QFrame(self.content_widget)
        self.drop_indicator.setFrameShape(QFrame.Shape.VLine)
        self.drop_indicator.setLineWidth(3)
        self.drop_indicator.setObjectName("dropIndicator")
        self.drop_indicator.hide()

        self.setAcceptDrops(True)

    def update_view(self, data: dict):
        self.group_containers.clear()
        while self.content_layout.count():
            child = self.content_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        groups = data.get("groups", [])
        programs = data.get("programs", {})
        
        programs_by_group = {group['id']: [] for group in groups}
        for prog_id, prog_data in programs.items():
            group_id = prog_data.get('group_id')
            if group_id in programs_by_group:
                programs_by_group[group_id].append(prog_data)
        
        for group_id in programs_by_group:
            programs_by_group[group_id].sort(key=lambda p: p.get("order", 0))

        row, col = 0, 0
        for group_data in groups:
            group_id = group_data['id']
            container = GroupContainerWidget(group_data)
            self.group_containers[group_id] = container
            
            container.header_widget.customContextMenuRequested.connect(self._on_group_context_menu)
            
            programs_in_group = programs_by_group.get(group_id, [])
            if not programs_in_group:
                empty_label = QLabel("(此分组为空)")
                empty_label.setStyleSheet("color: #999; padding: 10px;")
                container.add_card(empty_label)
            else:
                for prog_data in programs_in_group:
                    icon = icon_service.get_program_icon(prog_data['path'])
                    card = CardWidget(prog_data, icon)
                    card.doubleClicked.connect(self.item_double_clicked)
                    card.customContextMenuRequested.connect(self._on_card_context_menu)
                    container.add_card(card)
            
            self.content_layout.addWidget(container, row, col)
            col += 1
            if col >= self.COLUMNS:
                col = 0
                row += 1
        
        self.content_layout.setRowStretch(self.content_layout.rowCount(), 1)


    def _on_card_context_menu(self, program_id, event):
        menu = MenuFactory.create_context_menu('program', program_id, self)
        menu.exec_(event.globalPos())

    def _on_group_context_menu(self, group_id, event):
        menu = MenuFactory.create_context_menu('group', group_id, self)
        menu.exec_(event.globalPos())

    def dragEnterEvent(self, event: QDragEnterEvent):
        if event.mimeData().hasText() and ":" in event.mimeData().text():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dragLeaveEvent(self, event):
        self.drop_indicator.hide()

    def dragMoveEvent(self, event: QDragMoveEvent):
        pos_in_content = event.position().toPoint()
        mime_text = event.mimeData().text()
        drag_type, _ = mime_text.split(":", 1)

        indicator_rect = None
        if drag_type == "card":
            _, _, indicator_rect = self._find_card_drop_pos(pos_in_content)
        elif drag_type == "group":
            _, indicator_rect = self._find_group_drop_pos(pos_in_content)
        
        if indicator_rect:
            self.drop_indicator.setGeometry(indicator_rect)
            self.drop_indicator.show()
            event.accept()
        else:
            self.drop_indicator.hide()
            event.ignore()

    def dropEvent(self, event: QDropEvent):
        self.drop_indicator.hide()
        if not event.mimeData().hasText():
            event.ignore(); return

        pos = event.position().toPoint()
        mime_text = event.mimeData().text()
        drag_type, source_id = mime_text.split(":", 1)

        if drag_type == "card":
            target_group_id, target_index, _ = self._find_card_drop_pos(pos)
            if target_group_id is not None:
                self.program_dropped.emit(source_id, target_group_id, target_index)
                event.acceptProposedAction()
        elif drag_type == "group":
            target_index, _ = self._find_group_drop_pos(pos)
            
            group_ids = [self.content_layout.itemAt(i).widget().group_id for i in range(self.content_layout.count()) if self.content_layout.itemAt(i) and self.content_layout.itemAt(i).widget()]

            if source_id in group_ids:
                group_ids.remove(source_id)
                if target_index > len(group_ids): target_index = len(group_ids)
                group_ids.insert(target_index, source_id)
                self.group_order_changed.emit(group_ids)
                event.acceptProposedAction()
        
        event.ignore()

    def _find_card_drop_pos(self, pos: QPoint) -> tuple[str | None, int, QRect | None]:
        target_container = self.content_widget.childAt(pos)
        while target_container and not isinstance(target_container, GroupContainerWidget):
            target_container = target_container.parentWidget()
        
        if not target_container: return None, -1, None

        layout = target_container.card_layout
        local_pos = target_container.card_container.mapFrom(self.content_widget, pos)

        # 检查布局是否存在或为空
        if not layout or layout.count() == 0:
            # 如果分组为空，则返回索引0和默认指示器
            rect = QRect(0, 0, 3, 90)
            final_rect_pos = target_container.card_container.mapTo(self.content_widget, rect.topLeft())
            final_rect = QRect(final_rect_pos, rect.size())
            return target_container.group_id, 0, final_rect

        cell_width = (target_container.card_container.width() - (layout.horizontalSpacing() * (layout.columnCount() -1))) / layout.columnCount()
        cell_height = 90 + layout.verticalSpacing()
        
        row = math.floor(local_pos.y() / cell_height) if cell_height > 0 else 0
        col = math.floor(local_pos.x() / cell_width) if cell_width > 0 else 0
        
        target_index = row * layout.columnCount() + col
        
        card_count = layout.count()
        if target_index > card_count:
            target_index = card_count

        rect = QRect()
        # 【核心修复】处理边界条件，防止访问NoneType
        if target_index < card_count:
            # 情况1：插入到现有卡片之前
            item = layout.itemAt(target_index)
            if item and item.widget():
                widget = item.widget()
                rect.setRect(widget.x() - 5, widget.y(), 3, widget.height())
        else:
            # 情况2：追加到所有卡片之后
            item = layout.itemAt(card_count - 1)
            if item and item.widget():
                widget = item.widget()
                rect.setRect(widget.x() + widget.width() + 5, widget.y(), 3, widget.height())

        if rect.isNull():
            return target_container.group_id, target_index, None

        final_rect_pos = target_container.card_container.mapTo(self.content_widget, rect.topLeft())
        final_rect = QRect(final_rect_pos, rect.size())

        return target_container.group_id, target_index, final_rect

    def _find_group_drop_pos(self, pos: QPoint) -> tuple[int, QRect | None]:
        target_index = 0
        min_dist = float('inf')
        
        if self.content_layout.count() == 0:
            return 0, None

        for i in range(self.content_layout.count()):
            item = self.content_layout.itemAt(i)
            if item and item.widget():
                dist = (pos - item.geometry().center()).manhattanLength()
                if dist < min_dist:
                    min_dist = dist
                    target_index = i
        
        rect = QRect()
        item = self.content_layout.itemAt(target_index)
        if item and item.widget():
            g = item.geometry()
            if pos.x() < g.center().x():
                rect.setRect(g.x() - 8, g.y(), 3, g.height())
            else:
                rect.setRect(g.right() + 5, g.y(), 3, g.height())
                target_index += 1

        return target_index, rect
```
### tree_view.py
```python
# desktop_center/src/features/program_launcher/views/modes/tree_view.py
import logging
import os
from PySide6.QtWidgets import (QTreeWidget, QTreeWidgetItem, QAbstractItemView,
                               QVBoxLayout, QHeaderView, QGroupBox, QHBoxLayout)
from PySide6.QtGui import QIcon, QDropEvent, QFont, QResizeEvent, QColor
from PySide6.QtCore import Qt, QSize

from .base_view import BaseViewMode
from ...services.icon_service import icon_service
from ...widgets.menu_factory import MenuFactory

class LauncherTreeWidget(QTreeWidget):
    """
    专用于树状视图的自定义QTreeWidget，以可靠地处理拖放事件。
    """
    def __init__(self, parent_view: BaseViewMode):
        super().__init__(parent_view)
        self.parent_view = parent_view

    def dropEvent(self, event: QDropEvent):
        # 记录拖放前的信息
        source_item = self.currentItem()
        if not source_item:
            event.ignore(); return
        
        source_data = source_item.data(0, Qt.ItemDataRole.UserRole)
        source_type = source_data.get('type')
        source_id = source_data.get('id')

        # 执行验证逻辑
        target_item = self.itemAt(event.position().toPoint())
        drop_indicator = self.dropIndicatorPosition()

        if source_type == 'group':
            if (target_item and target_item.parent()) or drop_indicator == QAbstractItemView.DropIndicatorPosition.OnItem:
                logging.warning("Illegal drop: Group cannot be dropped into another group.")
                event.ignore(); return
        elif source_type == 'program':
            if (target_item is None or target_item.parent() is None) and drop_indicator != QAbstractItemView.DropIndicatorPosition.OnItem:
                logging.warning("Illegal drop: Program cannot be a top-level item.")
                event.ignore(); return
        
        # 核心修复：先调用父类方法，让Qt完成UI移动
        super().dropEvent(event)

        # --- UI已经更新，现在分析新状态并发射精确信号 ---
        logging.info("Drop event processed by QTreeWidget, analyzing new structure...")

        if source_type == 'group':
            root = self.invisibleRootItem()
            new_group_order = [root.child(i).data(0, Qt.ItemDataRole.UserRole)['id'] for i in range(root.childCount())]
            self.parent_view.group_order_changed.emit(new_group_order)
            logging.info(f"Emitted group_order_changed: {new_group_order}")

        elif source_type == 'program':
            new_parent_item = source_item.parent()
            if not new_parent_item:
                logging.error("Program ended up in an invalid top-level position after drop.")
                return

            target_group_data = new_parent_item.data(0, Qt.ItemDataRole.UserRole)
            target_group_id = target_group_data.get('id')
            new_index = new_parent_item.indexOfChild(source_item)
            
            self.parent_view.program_dropped.emit(source_id, target_group_id, new_index)
            logging.info(f"Emitted program_dropped: program '{source_id}' to group '{target_group_id}' at index {new_index}")


class TreeViewMode(BaseViewMode):
    """
    树状视图模式的实现。
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)

        # 1. 创建外层容器，它将占据100%宽度
        outer_container = QGroupBox() # 移除标题
        outer_container.setObjectName("outerTreeContainer") # 设置对象名
        outer_layout = QHBoxLayout(outer_container)

        # 2. 创建内层容器（宽度为50%）
        self.tree_container = QGroupBox() # 移除标题
        self.tree_container.setObjectName("innerTreeContainer") # 设置对象名
        inner_layout = QVBoxLayout(self.tree_container)
        
        self.tree = LauncherTreeWidget(self)
        self.tree.setObjectName("launcherTreeView")
        self.tree.setHeaderHidden(True)
        self.tree.setColumnCount(2)
        self.tree.setIndentation(20)

        header = self.tree.header()
        # --- 最终列宽策略 ---
        # 第一列拉伸，占据所有可用空间
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        # 第二列根据内容自适应宽度
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        header.setStretchLastSection(False)

        self.tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.tree.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)
        self.tree.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.tree.setDragEnabled(True)
        self.tree.setAcceptDrops(True)
        self.tree.setDropIndicatorShown(True)

        # 3. 组装UI层级
        inner_layout.addWidget(self.tree)             # 树 -> 内层容器
        outer_layout.addWidget(self.tree_container)   # 内层容器 -> 外层布局
        outer_layout.addStretch(1)                    # 添加弹簧以填充右侧空白
        layout.addWidget(outer_container)             # 外层容器 -> 主布局

        self.tree.itemDoubleClicked.connect(self._on_item_double_clicked)
        self.tree.customContextMenuRequested.connect(self._on_context_menu)

    def update_view(self, data: dict):
        current_search = self.parent().search_bar.text() if self.parent() and hasattr(self.parent(), 'search_bar') else ""
        
        # 应用从配置中读取的样式
        config = data.get('tree_view_config', {})
        icon_size = config.get('icon_size', 20)
        font_size = config.get('font_size', 13)
        
        self.tree.setIconSize(QSize(icon_size, icon_size))
        
        font = self.tree.font()
        font.setPointSize(font_size)
        self.tree.setFont(font)

        self.tree.blockSignals(True)
        try:
            self.tree.clear()
            groups = data.get("groups", [])
            programs = data.get("programs", {})
            programs_by_group = {}
            for prog_id, prog_data in programs.items():
                group_id = prog_data.get('group_id')
                if group_id not in programs_by_group: programs_by_group[group_id] = []
                programs_by_group[group_id].append(prog_data)
            for group_id in programs_by_group:
                programs_by_group[group_id].sort(key=lambda p: p.get("order", 0))

            for group_data in groups:
                group_id = group_data['id']
                group_programs = programs_by_group.get(group_id, [])
                
                # 创建分组项，并直接设置文本
                group_item = QTreeWidgetItem(self.tree)
                group_item.setText(0, group_data['name'])
                group_item.setText(1, str(len(group_programs)))
                
                # 设置数据和标识
                group_item.setData(0, Qt.ItemDataRole.UserRole, {"id": group_id, "type": "group", "name": group_data['name']})
                group_item.setFlags(group_item.flags() | Qt.ItemFlag.ItemIsDropEnabled)
                
                # 设置分组的特殊样式
                font = group_item.font(0)
                font.setWeight(QFont.Bold)
                group_item.setFont(0, font)
                group_item.setTextAlignment(1, Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
                
                # 明确设置第一列（名称）的颜色
                group_item.setForeground(0, QColor("#303133")) # 深灰色

                # 设置第二列数字的颜色为更淡的灰色
                group_item.setForeground(1, QColor("#B0B0B0"))
                
                # 设置第二列数字的字体大小比程序名字小3个数值
                count_font = group_item.font(1)
                count_font.setPointSize(self.tree.font().pointSize() - 3)
                group_item.setFont(1, count_font)

                # 添加程序子项
                for prog_data in group_programs:
                    program_item = QTreeWidgetItem(group_item)
                    # 在名称前添加空格以增加与图标的距离
                    program_item.setText(0, "   " + prog_data['name'])
                    program_item.setIcon(0, icon_service.get_program_icon(prog_data['path']))
                    program_item.setData(0, Qt.ItemDataRole.UserRole, {"id": prog_data['id'], "type": "program", "name": prog_data['name'], "path": prog_data['path']})
                    program_item.setFlags(program_item.flags() & ~Qt.ItemFlag.ItemIsDropEnabled)
                
                group_item.setExpanded(True)
        finally:
            self.tree.blockSignals(False)
        
        if current_search:
            self.filter_items(current_search)

    def get_current_structure(self) -> dict:
        """
        从当前的UI树状态中，反向生成一份完整的数据结构字典。
        """
        new_groups, new_programs = [], {}
        root = self.tree.invisibleRootItem()
        
        # 遍历所有顶层项目（即分组）
        for i in range(root.childCount()):
            group_item = root.child(i)
            group_data = group_item.data(0, Qt.ItemDataRole.UserRole)
            
            # 确保这是一个有效的分组项目
            if not isinstance(group_data, dict) or group_data.get('type') != 'group':
                continue
            
            group_id = group_data['id']
            new_groups.append({"id": group_id, "name": group_data['name']})
            
            # 遍历该分组下的所有子项目（即程序）
            for j in range(group_item.childCount()):
                program_item = group_item.child(j)
                program_data = program_item.data(0, Qt.ItemDataRole.UserRole)

                # 确保这是一个有效的程序项目
                if not isinstance(program_data, dict) or program_data.get('type') != 'program':
                    continue
                
                program_id = program_data['id']
                # 从 program_data 中安全地获取 'path'
                path = program_data.get('path', '') # 使用 .get() 避免 KeyError
                new_programs[program_id] = {
                    "id": program_id,
                    "group_id": group_id,
                    "name": program_data['name'],
                    "path": path,
                    "order": j
                }
        return {"groups": new_groups, "programs": new_programs}

    def _on_item_double_clicked(self, item: QTreeWidgetItem):
        data = item.data(0, Qt.ItemDataRole.UserRole)
        if data and data.get('type') == 'program':
            self.item_double_clicked.emit(data['id'])
            
    def _on_context_menu(self, pos):
        item = self.tree.itemAt(pos)
        if not item:
            return
        
        data = item.data(0, Qt.ItemDataRole.UserRole)
        item_type = data.get('type')
        item_id = data.get('id')

        if not item_type or not item_id:
            return

        menu = MenuFactory.create_context_menu(item_type, item_id, self)
        menu.exec_(self.tree.mapToGlobal(pos))

    def resizeEvent(self, event: QResizeEvent):
        """
        重写 resizeEvent 以动态设置容器宽度为父窗口的一半。
        """
        super().resizeEvent(event)
        # 减去边距，使计算更精确
        new_width = (self.width() - self.layout().contentsMargins().left() * 2) * 0.35
        self.tree_container.setMaximumWidth(int(new_width))

```
### add_program_dialog.py
```python
# desktop_center/src/features/program_launcher/widgets/add_program_dialog.py
import os
from PySide6.QtWidgets import (QDialog, QVBoxLayout, QLineEdit, QDialogButtonBox, QLabel,
                               QFormLayout, QComboBox, QPushButton, QHBoxLayout, QFileDialog,
                               QMessageBox)
from PySide6.QtCore import Slot, QFileInfo

class AddProgramDialog(QDialog):
    """
    一个专用的对话框，用于添加新程序或编辑现有程序。
    """
    # 【核心修复】增加 default_group_id 参数以支持快捷添加模式
    def __init__(self, groups: list, program_to_edit: dict = None, default_group_id: str = None, parent=None):
        super().__init__(parent)
        self.is_edit_mode = program_to_edit is not None

        title = "编辑程序" if self.is_edit_mode else "添加新程序"
        self.setWindowTitle(title)
        self.setMinimumWidth(450)

        # -- UI 组件 --
        layout = QFormLayout(self)
        layout.setSpacing(10)

        # 分组选择
        self.group_combo = QComboBox()
        for group in groups:
            self.group_combo.addItem(group['name'], group['id'])
        
        # 程序名称
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("例如：谷歌浏览器")

        # 文件路径
        path_layout = QHBoxLayout()
        self.path_edit = QLineEdit()
        self.path_edit.setReadOnly(True)
        self.path_edit.setPlaceholderText("请选择可执行文件...")
        self.browse_btn = QPushButton("浏览...")
        path_layout.addWidget(self.path_edit)
        path_layout.addWidget(self.browse_btn)

        # 对话框按钮
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.ok_button = self.button_box.button(QDialogButtonBox.StandardButton.Ok)
        
        # 【核心修复】重构预设值逻辑
        group_id_to_select = None
        if self.is_edit_mode:
            self.name_edit.setText(program_to_edit.get('name', ''))
            self.path_edit.setText(program_to_edit.get('path', ''))
            group_id_to_select = program_to_edit.get('group_id')
        elif default_group_id:
            group_id_to_select = default_group_id
        
        if group_id_to_select:
            index = self.group_combo.findData(group_id_to_select)
            if index != -1:
                self.group_combo.setCurrentIndex(index)
        
        self.ok_button.setEnabled(False)
        self.validate_input()

        layout.addRow(QLabel("所属分组:"), self.group_combo)
        layout.addRow(QLabel("程序名称:"), self.name_edit)
        layout.addRow(QLabel("文件路径:"), path_layout)
        layout.addRow(self.button_box)

        # -- 连接信号 --
        self.browse_btn.clicked.connect(self.browse_file)
        self.name_edit.textChanged.connect(self.validate_input)
        self.path_edit.textChanged.connect(self.validate_input)
        self.button_box.accepted.connect(self.on_accept)
        self.button_box.rejected.connect(self.reject)

    @Slot()
    def browse_file(self):
        """打开文件对话框以选择文件。"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "选择一个可执行文件",
            "",
            "可执行文件 (*.exe);;所有文件 (*)"
        )
        if file_path:
            self.path_edit.setText(file_path)
            if not self.name_edit.text() and not self.is_edit_mode:
                program_name = os.path.splitext(os.path.basename(file_path))[0]
                self.name_edit.setText(program_name.replace('_', ' ').title())

    @Slot()
    def validate_input(self):
        """验证输入是否有效，以启用/禁用OK按钮。"""
        name_ok = bool(self.name_edit.text().strip())
        path_ok = bool(self.path_edit.text().strip())
        self.ok_button.setEnabled(name_ok and path_ok)

    @Slot()
    def on_accept(self):
        """
        在接受对话框前，验证文件路径的有效性。
        """
        file_path = self.path_edit.text().strip()
        file_info = QFileInfo(file_path)

        if not file_info.exists():
            QMessageBox.warning(self, "路径无效", f"文件路径不存在：\n{file_path}")
            return
        
        if not file_info.isFile():
            QMessageBox.warning(self, "路径无效", f"指定的路径不是一个文件：\n{file_path}")
            return

        # 在Windows上，可以进一步检查是否为.exe，但为了跨平台兼容性，我们只检查isExecutable
        # if sys.platform == "win32" and not file_path.lower().endswith('.exe'):
        #     reply = QMessageBox.question(self, "非标准文件", "这个文件似乎不是一个标准的可执行文件 (.exe)。\n您确定要添加吗？",
        #                                  QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        #                                  QMessageBox.StandardButton.No)
        #     if reply == QMessageBox.StandardButton.No:
        #         return

        if not file_info.isExecutable():
             QMessageBox.warning(self, "文件不可执行", f"系统报告该文件不可执行：\n{file_path}")
             return

        self.accept()

    def get_program_details(self) -> tuple[str, str, str]:
        """获取用户输入的程序详情。"""
        group_id = self.group_combo.currentData()
        program_name = self.name_edit.text().strip()
        file_path = self.path_edit.text().strip()
        return group_id, program_name, file_path
```
### card_widget.py
```python
# desktop_center/src/features/program_launcher/widgets/card_widget.py
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel
from PySide6.QtGui import QIcon, QMouseEvent, QContextMenuEvent, QDrag, QPixmap, QPainter
from PySide6.QtCore import Qt, Signal, QSize, QMimeData, QPoint

class CardWidget(QWidget):
    """
    一个独立的卡片控件，用于在图标视图中显示单个程序。
    它现在没有自己的背景或边框，样式由父容器和QSS控制。
    """
    doubleClicked = Signal(str)
    customContextMenuRequested = Signal(str, QContextMenuEvent)

    def __init__(self, program_data: dict, icon: QIcon, parent=None):
        super().__init__(parent)
        # 不再设置固定的ObjectName，让QSS可以更灵活地通过父子选择器控制
        self.program_id = program_data.get('id')
        self.program_data = program_data
        self.setFixedSize(90, 90) # 尺寸微调
        self.setToolTip(program_data.get('path', ''))
        self.drag_start_position = None

        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5) # 减小内边距
        layout.setSpacing(5)

        self.icon_label = QLabel()
        self.icon_label.setPixmap(icon.pixmap(QSize(40, 40))) # 图标尺寸微调
        self.icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.icon_label.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)
        
        self.name_label = QLabel(program_data.get('name', ''))
        self.name_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.name_label.setWordWrap(True)
        self.name_label.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)

        layout.addWidget(self.icon_label)
        layout.addStretch()
        layout.addWidget(self.name_label)
        layout.addStretch()

    def mousePressEvent(self, event: QMouseEvent):
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_start_position = event.position().toPoint()
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event: QMouseEvent):
        if not (event.buttons() & Qt.MouseButton.LeftButton): return
        if not self.drag_start_position or (event.position().toPoint() - self.drag_start_position).manhattanLength() < 10: return

        drag = QDrag(self.parentWidget())
        mime_data = QMimeData()
        mime_data.setText(f"card:{self.program_id}")
        drag.setMimeData(mime_data)

        drag_pixmap = QPixmap(self.size())
        drag_pixmap.fill(Qt.GlobalColor.transparent)
        painter = QPainter(drag_pixmap)
        painter.setOpacity(0.7)
        painter.drawPixmap(0, 0, self.grab())
        painter.end()
        drag.setPixmap(drag_pixmap)
        drag.setHotSpot(event.position().toPoint())

        drag.exec(Qt.DropAction.MoveAction)

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        self.doubleClicked.emit(self.program_id)
        super().mouseDoubleClickEvent(event)
        
    def contextMenuEvent(self, event: QContextMenuEvent):
        self.customContextMenuRequested.emit(self.program_id, event)
        super().contextMenuEvent(event)
```
### delete_group_dialog.py
```python
# desktop_center/src/features/program_launcher/widgets/delete_group_dialog.py
from PySide6.QtWidgets import (QDialog, QVBoxLayout, QLabel, QRadioButton,
                               QComboBox, QDialogButtonBox, QWidget, QHBoxLayout)

class DeleteGroupDialog(QDialog):
    """
    一个自定义对话框，用于处理删除非空分组时的用户选择。
    """
    def __init__(self, group_name: str, other_groups: list, parent=None):
        super().__init__(parent)
        self.setWindowTitle("删除分组")
        self.setMinimumWidth(350)

        self.other_groups = other_groups
        self.result = (None, None)

        layout = QVBoxLayout(self)
        
        main_label = QLabel(f"分组 '{group_name}' 不为空。请选择如何处理其中的程序：")
        layout.addWidget(main_label)

        # 选项1: 移动到其他分组
        self.move_radio = QRadioButton("将所有程序移动到另一个分组:")
        layout.addWidget(self.move_radio)
        
        move_widget = QWidget()
        move_layout = QHBoxLayout(move_widget)
        move_layout.setContentsMargins(20, 0, 0, 0)
        self.group_combo = QComboBox()
        for group in self.other_groups:
            self.group_combo.addItem(group['name'], group['id'])
        move_layout.addWidget(self.group_combo)
        layout.addWidget(move_widget)
        
        # 选项2: 删除所有程序
        self.delete_all_radio = QRadioButton("删除此分组及其中的所有程序")
        layout.addWidget(self.delete_all_radio)

        # 根据是否有其他分组来设置默认状态
        if self.other_groups:
            self.move_radio.setChecked(True)
        else:
            self.move_radio.setText("将所有程序移动到一个新的'默认分组'")
            self.move_radio.setChecked(True)
            self.group_combo.setVisible(False)
        
        self.move_radio.toggled.connect(self.group_combo.setEnabled)

        # 按钮
        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def accept(self):
        """当用户点击OK时，保存结果。"""
        if self.move_radio.isChecked():
            target_group_id = self.group_combo.currentData() if self.other_groups else None
            self.result = ('move', target_group_id)
        elif self.delete_all_radio.isChecked():
            self.result = ('delete_all', None)
        super().accept()

    def get_result(self) -> tuple:
        """获取用户的选择结果。"""
        return self.result
```
### empty_state_widget.py
```python
# desktop_center/src/features/program_launcher/widgets/empty_state_widget.py
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton
from PySide6.QtGui import QIcon, QPixmap
from PySide6.QtCore import Qt, Signal

class EmptyStateWidget(QWidget):
    """
    一个用于显示空状态的占位符控件，引导用户进行初始操作。
    """
    add_group_requested = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.setSpacing(20)

        # 图标
        icon_label = QLabel()
        # 使用一个通用的、友好的图标
        pixmap = QIcon.fromTheme("document-new").pixmap(64, 64)
        icon_label.setPixmap(pixmap)
        icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # 标题
        title_label = QLabel("欢迎使用程序启动器")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet("font-size: 20px; font-weight: bold;")

        # 描述
        description_label = QLabel("这里还没有任何内容。\n点击下方的按钮，从创建第一个分组开始吧！")
        description_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        description_label.setStyleSheet("font-size: 14px; color: #888;")

        # 动作按钮
        self.add_group_btn = QPushButton(QIcon.fromTheme("list-add"), " 创建第一个分组")
        self.add_group_btn.setStyleSheet("padding: 10px 20px; font-size: 16px;")
        self.add_group_btn.clicked.connect(self.add_group_requested)

        layout.addWidget(icon_label)
        layout.addWidget(title_label)
        layout.addWidget(description_label)
        layout.addWidget(self.add_group_btn)
```
### group_dialog.py
```python
# desktop_center/src/features/program_launcher/widgets/group_dialog.py
from PySide6.QtWidgets import QDialog, QVBoxLayout, QLineEdit, QDialogButtonBox, QLabel

class GroupDialog(QDialog):
    """
    一个简单的对话框，用于获取用户输入的分组名称。
    """
    def __init__(self, parent=None, current_name=""):
        super().__init__(parent)
        self.setWindowTitle("分组信息")
        
        layout = QVBoxLayout(self)
        
        self.label = QLabel("分组名称:")
        self.line_edit = QLineEdit()
        if current_name:
            self.line_edit.setText(current_name)
            self.setWindowTitle("重命名分组")

        self.button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)

        layout.addWidget(self.label)
        layout.addWidget(self.line_edit)
        layout.addWidget(self.button_box)
        
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        self.line_edit.returnPressed.connect(self.accept)

    def get_group_name(self) -> str:
        """获取用户输入的文本。"""
        return self.line_edit.text().strip()
```
### group_header_widget.py
```python
# desktop_center/src/features/program_launcher/widgets/group_header_widget.py
from PySide6.QtWidgets import QWidget, QHBoxLayout, QLabel
from PySide6.QtGui import QContextMenuEvent
from PySide6.QtCore import Qt, Signal

class GroupHeaderWidget(QWidget):
    """
    一个分组标题显示控件，现在只负责显示标题和发出右键菜单信号。
    拖拽逻辑已移至GroupContainerWidget。
    """
    customContextMenuRequested = Signal(str, QContextMenuEvent)

    def __init__(self, group_data: dict, parent=None):
        super().__init__(parent)
        self.setObjectName("GroupHeaderWidget")
        self.group_id = group_data.get('id')
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        self.title_label = QLabel(group_data.get('name', ''))
        self.title_label.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)
        layout.addWidget(self.title_label)
        
    def contextMenuEvent(self, event: QContextMenuEvent):
        self.customContextMenuRequested.emit(self.group_id, event)
        super().contextMenuEvent(event)
```
### menu_factory.py
```python
# desktop_center/src/features/program_launcher/widgets/menu_factory.py
from PySide6.QtWidgets import QMenu
from PySide6.QtGui import QAction

class MenuFactory:
    """
    一个工厂类，用于创建程序启动器中统一的上下文菜单。
    """
    @staticmethod
    def create_context_menu(item_type: str, item_id: str, parent_view):
        """
        根据项目类型和ID，创建一个上下文菜单。

        Args:
            item_type: 'group' 或 'program'.
            item_id: 项目的唯一ID.
            parent_view: 调用此菜单的视图控件，用于连接信号。

        Returns:
            一个配置好的 QMenu 实例。
        """
        menu = QMenu(parent_view)
        
        if item_type == 'group':
            add_program_action = QAction("添加程序到此分组...", menu)
            add_program_action.triggered.connect(lambda: parent_view.add_program_to_group_requested.emit(item_id))
            menu.addAction(add_program_action)
            
            menu.addSeparator()
            
            rename_action = QAction("重命名分组", menu)
            rename_action.triggered.connect(lambda: parent_view.edit_item_requested.emit(item_id, 'group'))
            menu.addAction(rename_action)
            
            delete_action = QAction("删除分组", menu)
            delete_action.triggered.connect(lambda: parent_view.delete_item_requested.emit(item_id, 'group'))
            menu.addAction(delete_action)

        elif item_type == 'program':
            launch_action = QAction("启动", menu)
            launch_action.triggered.connect(lambda: parent_view.item_double_clicked.emit(item_id))
            menu.addAction(launch_action)
            
            edit_action = QAction("编辑...", menu)
            edit_action.triggered.connect(lambda: parent_view.edit_item_requested.emit(item_id, 'program'))
            menu.addAction(edit_action)
            
            delete_action = QAction("删除", menu)
            delete_action.triggered.connect(lambda: parent_view.delete_item_requested.emit(item_id, 'program'))
            menu.addAction(delete_action)
            
        return menu
```
### no_results_widget.py
```python
# desktop_center/src/features/program_launcher/widgets/no_results_widget.py
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel
from PySide6.QtGui import QIcon
from PySide6.QtCore import Qt

class NoResultsWidget(QWidget):
    """
    一个用于显示“无搜索结果”的占位符控件。
    """
    def __init__(self, parent=None):
        super().__init__(parent)

        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.setSpacing(20)

        # 图标
        icon_label = QLabel()
        pixmap = QIcon.fromTheme("edit-find").pixmap(64, 64)
        icon_label.setPixmap(pixmap)
        icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # 标题
        title_label = QLabel("未找到匹配项")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet("font-size: 20px; font-weight: bold;")

        # 描述
        description_label = QLabel("请尝试使用其他关键词进行搜索。")
        description_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        description_label.setStyleSheet("font-size: 14px; color: #888;")

        layout.addWidget(icon_label)
        layout.addWidget(title_label)
        layout.addWidget(description_label)
```
### icon_service.py
```python
# desktop_center/src/features/program_launcher/services/icon_service.py
from PySide6.QtGui import QIcon
from PySide6.QtWidgets import QFileIconProvider
from PySide6.QtCore import QFileInfo

class IconService:
    """
    一个单例服务，用于提供和缓存程序图标，避免重复加载和内存泄漏。
    """
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(IconService, cls).__new__(cls)
            cls._instance.icon_cache = {}
            cls._instance.icon_provider = QFileIconProvider()
        return cls._instance

    def get_program_icon(self, path: str) -> QIcon:
        """
        获取指定路径的程序图标。如果已缓存，则从缓存返回。
        """
        if not path or path in self.icon_cache:
            return self.icon_cache.get(path, QIcon.fromTheme("application-x-executable"))
        
        file_info = QFileInfo(path)
        if not file_info.exists():
            # 对于不存在的路径，也缓存一个默认图标，避免重复检查
            icon = QIcon.fromTheme("application-x-executable")
            self.icon_cache[path] = icon
            return icon

        icon = self.icon_provider.icon(file_info)
        if icon.isNull():
            icon = QIcon.fromTheme("application-x-executable")
        
        self.icon_cache[path] = icon
        return icon

    def clear_cache(self):
        """
        清空图标缓存。
        """
        self.icon_cache.clear()

# 创建一个全局实例供应用使用
icon_service = IconService()
```
### group_container_widget.py
```python
# desktop_center/src/features/program_launcher/widgets/group_container_widget.py
from PySide6.QtWidgets import QWidget, QVBoxLayout, QFrame, QGridLayout
from PySide6.QtGui import QMouseEvent, QDrag, QPixmap, QPainter
from PySide6.QtCore import Qt, QMimeData, QPoint

from .group_header_widget import GroupHeaderWidget

class GroupContainerWidget(QFrame):
    """
    一个容器控件，用于将一个分组（包括标题和程序卡片）显示为一个独立的卡片。
    其内部使用QGridLayout来确保程序卡片以完美的3列网格排列。
    """
    COLUMNS = 3

    def __init__(self, group_data: dict, parent=None):
        super().__init__(parent)
        self.setObjectName("GroupContainerWidget")
        self.group_id = group_data.get('id')
        self.drag_start_position = None
        self.card_count = 0

        self.setCursor(Qt.CursorShape.OpenHandCursor)
        
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(15, 10, 15, 15)
        main_layout.setSpacing(10)

        self.header_widget = GroupHeaderWidget(group_data)
        
        self.card_container = QWidget()
        # 【核心变更】使用 QGridLayout 替换 FlowLayout
        self.card_layout = QGridLayout(self.card_container)
        self.card_layout.setSpacing(10)
        
        main_layout.addWidget(self.header_widget)
        main_layout.addWidget(self.card_container)
        
        main_layout.addStretch(1)
        
    def add_card(self, card_widget):
        """向内部的GridLayout添加一个程序卡片。"""
        row = self.card_count // self.COLUMNS
        col = self.card_count % self.COLUMNS
        self.card_layout.addWidget(card_widget, row, col)
        self.card_count += 1

    def mousePressEvent(self, event: QMouseEvent):
        if event.button() == Qt.MouseButton.LeftButton and self.header_widget.geometry().contains(event.position().toPoint()):
            self.drag_start_position = event.position().toPoint()
            self.setCursor(Qt.CursorShape.ClosedHandCursor)
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event: QMouseEvent):
        self.setCursor(Qt.CursorShape.OpenHandCursor)
        super().mouseReleaseEvent(event)
        
    def mouseMoveEvent(self, event: QMouseEvent):
        if not (event.buttons() & Qt.MouseButton.LeftButton) or self.drag_start_position is None:
            return
        if (event.position().toPoint() - self.drag_start_position).manhattanLength() < 10:
            return

        drag = QDrag(self.parentWidget())
        mime_data = QMimeData()
        mime_data.setText(f"group:{self.group_id}")
        drag.setMimeData(mime_data)

        drag_pixmap = QPixmap(self.size())
        drag_pixmap.fill(Qt.GlobalColor.transparent)
        painter = QPainter(drag_pixmap)
        painter.setOpacity(0.7)
        painter.drawPixmap(0, 0, self.grab())
        painter.end()
        
        drag.setPixmap(drag_pixmap)
        drag.setHotSpot(event.position().toPoint())
        
        drag.exec(Qt.DropAction.MoveAction)
        self.setCursor(Qt.CursorShape.OpenHandCursor)
```
### style.qss
```qss
/* === 全局与基础 === */

#LauncherPageView {
    background-color: #f5f5f7;
    font-family: "Microsoft YaHei UI", "Segoe UI", sans-serif;
}

/* === 顶部工具栏 === */
QPushButton {
    background-color: #ffffff;
    border: 1px solid #dcdfe6;
    padding: 8px 15px;
    border-radius: 6px;
    font-size: 14px;
    color: #303133;
    min-height: 20px;
}
QPushButton:hover {
    background-color: #ecf5ff;
    color: #409eff;
    border-color: #c6e2ff;
}
QPushButton:pressed {
    background-color: #a0cfff;
    border-color: #a0cfff;
    color: #ffffff;
}
QPushButton:checked {
    background-color: #409eff;
    border-color: #409eff;
    color: #ffffff;
}

QLineEdit {
    background-color: #ffffff;
    border: 1px solid #dcdfe6;
    padding: 8px;
    border-radius: 6px;
    font-size: 14px;
}
QLineEdit:focus {
    border-color: #409eff;
}

/* === 视图区域 === */
QScrollArea {
    background-color: transparent;
    border: none;
}

/* 拖放指示器样式 */
#dropIndicator {
    background-color: #409eff;
}

/* === 卡片视图 (IconViewMode) - 最终网格布局样式 === */

/* 【核心变更】为GroupContainerWidget设置固定宽度，以容纳3列图标 */
#GroupContainerWidget {
    background-color: #ffffff;
    border: 1px solid #EBEEF5;
    border-radius: 8px;
    width: 320px; /* (90*3) + (10*2) + (15*2) = 270+20+30 = 320 */
}

#GroupHeaderWidget QLabel {
    font-size: 15px;
    font-weight: bold;
    color: #303133;
    padding: 5px 0px;
}

CardWidget {
    background-color: transparent;
    border: none;
    border-radius: 6px;
}
CardWidget:hover {
    background-color: #f5f7fa;
}
CardWidget QLabel {
    color: #606266;
    font-size: 13px;
}


/* === 树状视图 (TreeViewMode) - 保持不变 === */

#launcherTreeView {
    background-color: transparent;
    border: none;
    outline: 0;
}
#launcherTreeView::item {
    padding: 8px 2px;
    border-radius: 4px;
}
#launcherTreeView::item:hover,
#launcherTreeView::item:selected {
    background-color: #f0f0f0;
    color: #000000;
}
#launcherTreeView::item:selected:!active {
    background-color: #f0f0f0;
}
#launcherTreeView {
    qproperty-alternatingRowColors: false;
}
#outerTreeContainer, #innerTreeContainer {
    border: 1px solid #dcdfe6;
    border-radius: 6px;
    margin-top: 6px;
}
#innerTreeContainer {
    background-color: #fafafa;
}

/* === 滚动条 - 保持不变 === */
QScrollBar:vertical {
    border: none;
    background: #f5f5f7;
    width: 10px;
    margin: 0px 0px 0px 0px;
}
QScrollBar::handle:vertical {
    background: #dcdfe6;
    min-height: 20px;
    border-radius: 5px;
}
QScrollBar::handle:vertical:hover {
    background: #c0c4cc;
}
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
    border: none;
    background: none;
}
QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
    background: none;
}
```
## 目前需要做的
需要调整icon模式下的显示，得最终呈现的效果是，一行里有2个分组，也就是2列，然后每个分组里，每行显示三个程序，也就是三列
两列均分： “程序启动器”的视图区域，在程序启动并显示时，应被划分为两个宽度相等的列。
尺寸在启动时确定： 这两列的宽度，应该在窗口第一次显示时，根据当时的可用空间计算出来，并固定下来。
尺寸绝对固定：
不因内容变化： 向任一列（即分组容器）中添加或删除程序，不应导致该列的宽度发生任何变化。
不因窗口变化： 在程序启动后，即使用户最大化窗口或以任何方式调整窗口大小，这两列的宽度也应保持在启动时确定的那个像素值，不应随窗口拉伸或收缩。

期望的不是一个传统的“响应式”布局（即随窗口大小变化的布局），而是一个“一次性计算并固化”的静态布局。布局在初始化时填满可用空间，然后其尺寸就被“锁定”，成为一个固定的画布。
你先回答我是否真的理解了我的意图，可以举例说明


